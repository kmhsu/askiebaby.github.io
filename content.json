{"pages":[{"title":"林汶樺 | Askie Lin","text":"Hello World!我是 Askie Lin，目前鑽研前端領域中，這是我的履歷。我喜歡記錄我學習過的事物，也因此有可能出現錯誤的地方，如有文章不足之處，歡迎大家在我的文章底下留言告訴我唷，謝謝！除了學習 web 技術之外，我也很喜歡運動、彈吉他、跟貓玩，IG 分享著我的日常。","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"JavaScript 十個單字","text":"1. array 複數 像火車車廂的概念。 有順序性，可以放各種資料，但建議資料類型相似的一組資料結構/格式。 適合資料處理。 表達複數的概念，多個相同的複類別。 可以放不一樣型別的值，而強型別語言中都會相同型別的值。（2019-7-16 更新） 2. object 單數 單體 描述 Key，紀錄 value。 儲存某個東西各種屬性及方法，可以相關也可以不相關。 以車子舉例，有幾個輪子及什麼功能。 與類別的差異？類別可以抽換參數跟變數，可以複製相同的輪子。 狗(class)跟一隻狗(object)的差別！ pair，為值命名 用有意義的詞找到結果的一個容器 抽出我要的特性來描述，叫做抽象，很具象的。取決於問題。 class 抽象的結果，template 3. json 資料型別？ String 用來做什麼的？ 資料交換的格式。 輕便、傳 API、紀錄資料。 xml的另一個選擇，xml 不常被選擇使用，是因為適合拿來描述更複雜的東西，而傳輸資料通常較簡單。xml 體積大需要用套件解析才能給js使用。 parse，丟 json 吐出 object stringify，丟 object 吐出 json (String) 4. callback 把 function 當參數傳入另一個 function，就叫做 callback 需要某個 function 執行完，執行後才會執行的 function 異步常用 callback 就算沒有回傳值也是 callback 一定要用 CPS 攥寫風格 Ｑ：I/O? HOF?? 5. function 意思？ 一段可重複使用的程式碼，可當參數也可以接受參數 在js中提供什麼重要特性？（非他不可的特性） 建物件、一般用法 提供一個私有的命名環境（Scope） Lexical Environment 表現一個動詞、動作就會使用 function 可以選擇 return 或不 return 6. asyncronous 阻塞（blocking）：會造成等待的事情。要不要等待上一行結束，才執行我這一行。 常見同步阻塞、異步不阻塞 JS單執行緒的特性，會放到事件佇列的 function，避免阻塞到其他程式的執行 點餐範例、小鳥協助打果汁的範例 唯一讓 JS 非單線程的方法 配合執行環境而發生 7. closure 閉包 主要為了什麼而存在？ 在 function被產生當下記住其與會環境，在執行環境消失後仍可使用，因為記憶體位置保留著。 避免污染全域環境。 用程式形容？ 1234567function a (x) &#123; return() =&gt; console.log(x++);&#125;;var b = a(1);b(); // 1b(); // 2 JS用closure做什麼事？ 閉了誰，閉包的殺手級應用，就是要知道怎麼加上，怎麼拿掉。才知道閉包必要所在 =&gt; 避免全域污染。 8. Array.prototype.map() 遍歷 array 當中的每一個值，執行一個方法，回傳一個與原陣列同長的新 Array，不影響原本的陣列。 由 map 中的 callback 可自訂對 array item 做的事情 會 return 一個與相同長度的array immutable method 所有輸出都和輸入有關（一對一映射，映射函數） 9. loop 在特定條件下執行重複的程式碼，重複做一件事直到不符合條件 123for // 知次數while // 不知次數do ... while // 不知次數，至少一次 10. switch 是什麼？ 由上而下，進行條件（強制===）判斷，符合後執行直到 break 類似於菜單，廚師照點餐內容出餐 重點是滿足條件後，要從哪裡開始執行，下 break; 才停止 幾種寫法？（2019-7-16 更新） 123456789101112131415161718192021222324252627282930// example 1var fruit = 'Cherry';switch(fruit) &#123; case 'Apple': doSomething(); break; case 'Banana': doSomething(); break; Default: doSomething(); break;&#125;// example 2switch(somethingTrue) &#123; case a&gt;b: doSomething(); break; case a==b: doSomething(); break; Default: doSomething(); break;&#125;","link":"/javascript-ten-keywords/"},{"title":"使用手機測試本機網頁狀況的方法","text":"前置 確保電腦與手機裝置是在同一個網域底下 要確認電腦是否有裝 python 方法（2019-07-16 更新） 在 iTerm 進入專案的資料夾根目錄。 找到對外 IP，要找 IPV4 的 。 12ifconfig // MacOSipconfig // Windows 輸入以下指令，預設 port 是 8000。 port 儘量使用 4 位數以上（因爲有一些是預設的 port 號，可能會有重疊到的可能） 1python -m SimpleHTTPServer [port] 在瀏覽器輸入 IP:port，直接對外測試。","link":"/testing-for-mobile-browsers/"},{"title":"Git diff 指令快速查詢！","text":"名詞解釋 Staging Area (Index) 暫存區域是一個單純的檔案，一般來說放在 Git 目錄，儲存關於下一個提交的資訊。有時稱為索引（Index），但現在將它稱為暫存區域已開始成為標準。 用來比較差異的 diff 指令 比較 Working Directory 和 Staging Area 1git diff 比較 Working Directory 和 HEAD 1git diff head 比較 Working Directory 和該 commit 的 tree 物件 1git diff commit 比較 Staging Area 和 HEAD 123git diff --cachedgit diff --cached headgit diff --staged 比較 Staging Area 和該 commit 的 tree 物件 1git diff --cached commit 比較兩個 branch 之間的 HEAD 12git diff branchName..branchNamegit diff branchName branchName 比較 branch2 和兩個 branch 的共同祖先 1git diff branch1...branch2 比較兩個 commit 物件下的 tree 物件 1git diff commit commit","link":"/git-diff-cheatsheet/"},{"title":"ngrok 的設定，來架一個臨時伺服器！","text":"緣起 為了解決 facebook API 需要 https，所以利用 ngrok 架了一個網頁伺服器（Web Server）。 跟著步驟做，輕鬆就能架起來，並且可以達成以下這些事： Public URLs for sending previews to clients. 讓客戶可以輕鬆預覽你的專案。 Public URLs for testing your chatbot. 測試你的機器人。 Public URLs for SSH access to your Raspberry Pi. 輕鬆設定 SSH 連結樹莓派。 Public URLs for demoing from your own machine. 從自己的裝置 demo。 Public URLs for exposing your local web server. 架一個臨時伺服器。 Public URLs for testing on mobile devices. 測試行動裝置。 Public URLs for building webhook integrations. 步驟 1. 從官網下載 ngrok。 網址 2. 解壓縮 將檔案放在你的專案下，並且點兩下執行。 3. 取得 token 從官網註冊你的信箱，取得 token 4. 開啟你的 terminal（我使用 iTerm），進入專案底下執行： 1./ngrok authtoken &lt;YOUR_AUTH_TOKEN&gt; 5. 架起渠道： 1./ngrok http 80 6. 讓 localhost 對外 用 Python 的 SimpleHTTPServer 模組建立一個臨時網頁伺服器（Web Server），port 要與 ngrok 要開的 port 相同。 1python -m SimpleHTTPServer [port] 7. 大功告成 可以透過網址直接讓localhost 對外進行測試囉！不過要注意的是，如果關閉server，網址也會失效，下次重啟則是新的網址。","link":"/ngrok-localhost-server-settings/"},{"title":"使用 JQuery 透過 FormData 上傳檔案 (headers 帶 boundary)","text":"基礎知識 JQuery AJAX: contentType 不填寫時，預設為 application/x-www-form-urlencoded 。 FormData FormData 介面可為表單資料中的欄位/值建立相對應的的鍵/值對（key/value）集合，之後便可使用 XMLHttpRequest.send() 方法來送出資料。 它在編碼類型設定為 multipart/form-data 時會採用與表單相同的格式送出。 RFC1867 剛開始，http 協議中没有檔案上傳的功能，直到 RFC1867 為 http 協議添加了此功能。 在 RFC1867 中限定： &lt;form&gt; 的 method 必須是 POST。 enctype 屬性新增了 multipart/form-data 的選項。 &lt;input&gt; 的 type 屬性增加了 file 選項。 程式碼 html 1234567&lt;form action=\"server/api/items\" name=\"productForm\" enctype=\"multipart/form-data\" method=\"POST\"&gt; &lt;h3&gt;新增商品&lt;/h3&gt; &lt;input type=\"file\" name=\"files\" class=\"productFile\"&gt; &lt;input type=\"text\" class=\"productName\"&gt; &lt;input type=\"number\" min=\"1\" class=\"productPrice\"&gt; &lt;input type=\"submit\" value=\"送出\"&gt;&lt;/form&gt; JavaScript 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 取得表單let productForm = document.forms.namedItem('productForm')productForm.addEventListener('submit', function(event)&#123; post_items(event, productForm)&#125;)function api_post_items (event, form)&#123; // 取消表單預設提交 event.preventDefault() let name = document.querySelector('.productName').value let stock = document.querySelector('.productAmount').value let unit_price = document.querySelector('.productPrice').value let file = $('.productFile')[0].files[0] // 單個檔案 // 建立一個新的 FormData 物件 let formData = new FormData(form) // 追加新值到 FormData 物件已有的對應鍵上；若該鍵不存在，則為其追加新的鍵 formData.append('name', name) formData.append('cost', cost) formData.append('unit_price', unit_price) formData.append('images', file) let item = &#123; 'url': `$&#123; server &#125;/api/items`, 'type': 'POST', 'headers': &#123; // 'Content-Type': 'multipart/form-data', // 使用 multipart/form-data 在此不需要設定 Content-Type。 'X-Requested-With': 'XMLHttpRequest', 'Authorization': `Bearer $&#123; userToken &#125;`, &#125;, 'contentType': false, //required 'processData': false, // required 'mimeType': 'multipart/form-data', 'data': formData &#125; $.ajax(item) .done(function (response) &#123; console.log(response) closeLightBox() api_get_items() &#125;) .fail(function (response) &#123; console.log('api_post_user: Fail ' + response.responseText) &#125;) &#125; 注意！ 在 &lt;form&gt; 表單設定 enctype=&quot;multipart/form-data&quot;。 &lt;form&gt; 中，需要有 &lt;input type=&quot;file&quot;&gt;。 JavaScript 中 設定 contentType = false。 在傳送 multipart/formdata 時，希望不影響原表單設定，而直接將預設值改為 multipart/form-data。 JavaScript 中 設定 processData = false。 不去處理資料。 JavaScript 中 設定 cache = false，檔案不需緩存。 表單送出後，去檢查 Request Headers 看到我們有帶 boundary 成功傳輸。 Reference FormData - MDN Content-Type - MDN 通过jQuery Ajax使用FormData对象上传文件 浅谈contentType = false 从FormData到图片上传 Submitting multipart/form-data using jQuery and Ajax missing boundary in Content-Type for multipart posts","link":"/using-formdata-and-setting-multipart-to-upload-file-by-ajax/"},{"title":"自訂一個指令同時更新及備份 hexo 部落格（macOS）","text":"Preparation 建立備份的repository hexo 在 _comfig.yml 檔案可以設定部落格 hexo d 部署時，要部署到哪個repository，但是因為部署只會部署 hexo g (generate生成靜態網頁) 的 public 資料夾，我們也希望能備份樣式，所以要開好一個新的repository（我設為private），進入.git/config 修改備份的路徑。 修改 .git/config 檔案 123[remote &quot;origin&quot;]url = 準備用來備份樣式跟設定的repository.gitfetch = +refs/heads/*:refs/remotes/origin/* 流程 1. 進入 /bin 資料夾： 1cd /usr/local/bin 2. 檢視目前電腦有哪些指令： 1ls 3. 自訂你的個人指令，進入 insert 模式編輯內容： 1vim your-command PS. 若不存在這個檔案（你定義的名稱），vim 會在你儲存內容後自動建立這個檔案 4. 建立批次執行的指令們： 123456789#!/bin/bashcd 你的部落格絕對路徑git add .git commit --amend --no-editgit push -fcd 你的部落格絕對路徑hexo cl # 刪除已經生成的 public 資料夾hexo g -d # 根據新內容生成 public 資料夾，並部署上線 :wq 或是 :x 存檔離開，這時候再來 ls 看看指令們當中有出現你自訂的指令了。 可能會遇到的問題 權限不足 檢視指令的權限： 1ll -a your-command 如果發現權限只可讀，使用以下語法，加上執行的權限： 1chmod u+x your-command 執行你的指令 your-command 試試吧！ ps. 要確認你的每一行指令，你都知道在做什麼事情，否則會無預期的發生嚴重錯誤喔！","link":"/macos-command-backup-update-hexo-blog/"},{"title":"用 JavaScript 一步步打造程式基礎(Huli JS101課程筆記)","text":"Node.js 環境建置 node.js 不是程式語言，而是一個執行環境，能讓 JavaScript 運行於瀏覽器外。 安裝：官網。LTS 是較穩定的版本，Current 是有其他新的功能。 透過 iTerm 建立 js 檔案，並用 node 執行寫好的程式。 1. 建立 JavaScript：vim index.js 12// index.js console.log(123) 2. 用 node 執行寫好的程式碼 12$ node index.js=&gt; 123 直接用 node 執行 JavaScript 1. 執行 12$ node=&gt; 等同於進入瀏覽器的 console tab 2. 離開 快速鍵 control + c (輸入兩次) 或是輸入指令： 1$ .exit 邏輯運算 邏輯運算子 ||（或）、&amp;&amp;（和）、!（not） || 短路性質： 12345678910113 || 10// =&gt; 3// 程式遇到 3 時，因為是 truthy value，所以直接回傳 3，後面就直接不執行了。true || 10// =&gt; true// 程式遇到 true 時，true 符合條件造成短路，後面就直接不執行了。false || 10// =&gt; 10// 程式遇到 false 不符合條件，往後繼續執行，遇到 10 達成條件！回傳 10。 &amp;&amp; 短路性質： 12345678910113 &amp;&amp; 10// =&gt; 10// 第一個值符合條件，檢查第二個值是否符合條件，回傳第二個值 10。false &amp;&amp; 10// =&gt; false// 因為第一個值已經是 false，後面短路不執行，回傳 false。0 &amp;&amp; 10// =&gt; 0// 因為第一個值是 falsy value，後面短路不執行，回傳第一個值 0。 位元運算 位移運算子 &lt;&lt;、&gt;&gt; 了解電腦都是使用二進位做運算 100 =&gt; 2 的三次方 =&gt; 8 1000 =&gt; 2 的四次方 =&gt; 16 往左移 1 位，是乘以 2 倍 往左移 2 位，是乘以 2的2次方（4） 往右移 1 位，是除以 2 倍 往右移 2 位，是除以 2的2次方（4） 123456789101110 &lt;&lt; 1// 20 =&gt; 往左移一位，乘以2的1次方，= 10 * 210 &lt;&lt; 3 // 80 =&gt; 往左移三位，乘以2的3次方，= 10 * 81024 &gt;&gt; 1 // 512 =&gt; 往右移一位，除以2的1次方，= 1024 / 29 &gt;&gt; 1// 4 =&gt; 往右移一位，除以2的1次方，= 9 / 2，無條件捨去。 10 &gt;&gt; 1 會比 10*2 執行效能還要好。 位元運算子 &amp;、|、xor、not 都會換算成二進位來運算 &amp; and 位元運算子： 1210 &amp; 15// 10 =&gt; 1010 and 1111 = 1010(2) = 10(10) | or 位元運算子： 1210 &amp; 15// 15 =&gt; 1010 or 1111 = 1111(2) = 15(10) xor 位元運算子：當一個 falsy value 和 truthy value 共存時回傳 true，其他都是回傳 false。 1210 ^ 15// 5 =&gt; 1010 xor 1111 = 101(2) = 5(10) not：1變0，0變1 12~15// -16 =&gt; 1111 = 0000 （因電腦位元關係，原本的1111前有眾多的0，經過not運算會全轉為眾多的1） tips: 判斷數值是奇數或偶數 1234510 &amp; 1// 0 =&gt; 判斷最後一個字是零的話，代表是偶數。11 &amp; 1// 1 =&gt; 判斷最後一個字是一的話，代表是奇數。 變數 類型 Primitive type and Object type Primitive: string, boolean, number, null, undefined, symbol(ES6) Object: object (array, function, object) undefined: 已宣告，尚未值 not defined: 連宣告都沒啊！ 變數的運算注意的事情 變數是什麼類型！ 浮點數的誤差 複習一下等號的意義 一個等號 =，賦值。 兩個等號 ==，判斷值。 三個等號 ===，判斷類型與值。 123let a = 10 == 10console.log(a)// true，通常先執行右邊的程式 10 == 10，再把判斷結果賦值給 a。 物件與陣列的判斷 123456console.log([] === []) // falseconsole.log([1] === [1]) // falseconsole.log(&#123;&#125; === &#123;&#125;) // falseconsole.log(&#123;a: 1&#125; === &#123;a: 2&#125;) //false// 物件的判斷是根據記憶體位置。// 可以想像我有一台蘋果電腦，你也有一台蘋果電腦，但你的電腦不是我的電腦的概念。 我們只能往不同地方走去：判斷式 if… else… if… else if… else… switch 12345678910let number = 11if (!(number % 5)) &#123; // 了解：如果餘數是 0，代表可以被 5 整除 // 但 0 == false，利用 not 特性將結果變成 true 以進入判定 block // （可讀性差） console.log('5的倍數')&#125; else &#123; console.log('不是5的倍數')&#125; ternary 三元運算子 1(a &gt; b) ? 'big' : 'small' 迴圈/函式 實現輸入的數值會回傳一個區間陣列 12345678910function generateArray (min, max) &#123; var result = [] for(var i = min; i &lt;= max; i++) &#123; result.push(i) &#125; return result&#125;console.log(generateArray(5, 10)) // [5, 6, 7, 8, 9, 10] tip: 實作的時候，如果細節尚不清楚，可以試著先把function列出來，整理出邏輯（流程） 把 function 當成引數傳入 12345678910111213function transform(arr, transformFunction) &#123; var result = [] for (var i = 0; i &lt; arr.length; i++) &#123; result.push(transformFunction(arr[i])) // 執行傳入的 function &#125; return result&#125;function double (num) &#123; return num * 2&#125;transform([2, 4, 6], double) // 把 function 當成引數傳入 參數（Parameter）與引數（Argument） 參數：定義在 function 中 () 的變數。 引數：呼叫某函式時的 () 的變數。 123456funtcion myFunc(a, b) &#123; // a, b =&gt; 參數 console.log(arguments.length) // 引數的數量 console.log(arguments[0]) // 第一個引數 return arguments // &#123;a: 1, b: 2&#125; =&gt; 回傳引數類陣列物件&#125;myFunc(1, 2) // 1, 2 =&gt; 引數 arguments 跟你想的不一樣 arguments 物件是一個對應傳入函式之引數的類陣列（Array-like）物件。（參考：MDN） function 使用注意事項 pass by value pass by sharing https://blog.techbridge.cc/2018/06/23/javascript-call-by-value-or-reference/ return 不 return，有差嗎？ 差別只在於需不需要結果的。需要結果就回傳。 Number 類型的內建函式 常用的函式 字串轉數字 - 整數 1234567891011121314151617181920// 沒填進位制的話預設是 10 進位，可接受 2~36function roughScale(x, base) &#123; var parsed = Number.parseInt(x, base); if (Number.isNaN(parsed)) &#123; return 0; &#125; return parsed * 100;&#125;console.log(roughScale(' 0xF', 16));// expected output: 1500console.log(roughScale('321', 2));// expected output: 0parseInt('50個') // 50parseInt('50個', 10) // 50parseInt('50.2個', 10) // 50 字串轉數字 - 浮點數 1parseFloat('20.5') // 20.5 數字轉字串 12let num = 1num.toString() 四捨五入 12345function calculator (x) &#123; return Math.round(x)&#125;calculator(20.5456789) // 21小數點第一位四捨五入後回傳整數 無條件進位 12345function calculator (x) &#123; return Math.ceil(x)&#125;calculator(20.3456789) // 20，小數點第一位無條件進位後回傳整數 無條件捨去 12345function calculator (x) &#123; return Math.floor(x)&#125;calculator(20.3456789) // 20，小數點第一位無條件捨去後回傳整數 小數點後取幾位數（並四捨五入） 1234567function calculator (x) &#123; return x.toFixed(2) // 如果都不傳，則直接回傳整數（四捨五入） // 接受 0~20&#125;calculator(20.5456789) // 20.55calculator(20.5416789) // 20.54 開根號 12345function calculator (x) &#123; return Math.sqrt(x)&#125;calculator(9) // 3 平方 12345function calculator (x, y) &#123; return Math.pow(x, y)&#125;calculator(2, 10) // 1024 最大值 12let biggestNum = Number.MAX_VALUEconsole.log(biggestNum) // 1.7976931348623157e+308 最小值 12let smallestNum = Number.MIN_VALUEconsole.log(smallestNum) // 5e-324 隨機亂數 12345// 產生 0~0.99999 隨機小數Math.random()// 產生 1~10 隨機數字Math.floor(Math.random()*10 +1) 檢查是否是數字 123456789101112131415161718Number.isNaN(NaN); // trueNumber.isNaN(Number.NaN); // trueNumber.isNaN(0 / 0); // true// e.g. these would have been true with global isNaN()Number.isNaN('NaN'); // falseNumber.isNaN(undefined); // falseNumber.isNaN(&#123;&#125;); // falseNumber.isNaN('blabla'); // false// These all return falseNumber.isNaN(true);Number.isNaN(null);Number.isNaN(37);Number.isNaN('37');Number.isNaN('37.37');Number.isNaN('');Number.isNaN(' '); String 類型的內建函式 str.length：回傳字串的長度。 toString()：將物件轉字串。 str.replace()：。 ' hello '.trim()：回傳去除 ' hello ' 前後的空格，輸出'hello'這個字串。 str.indexOf('b')：在 str 找不找得到 b ，沒有則回傳 -1，有則回傳第一個 b 的起始位置，沒有則回傳 -1。 str.lastIndexOf('b')：在 str 找不找得到 b ，沒有則回傳 -1，有則回傳最後一個 b 的起始位置。 str.charCodeAt(5)：回傳 str 找第六個字的 keycode。 str.charAt(5)：回傳 str 找第六個字是哪一個字。 str.split(' ')：將 str 這個字串以 空格切開後回傳一個陣列。 str.slice(index1, b)：切字串，但是以範圍來切後回傳，索引也可以從字串最後算起。 12345678910111213var str = 'The quick brown fox jumps over the lazy dog.';console.log(str.slice(1));// expected output: \"the lazy dog.\"console.log(str.slice(4, 19));// expected output: \"quick brown fox\"console.log(str.slice(-4));// expected output: \"dog.\"console.log(str.slice(-9, -5));// expected output: \"lazy\" Array 類型的內建函式 練習 codepen collection 我們只能往不同地方走去：判斷式 練習一：判斷是否及格（連結） 練習二：BMI 計算 （連結） 綜合題目練習 Lv1 練習一：印出一到九（連結） 練習二：寫一個能夠印出 1~n 的函式（連結） 練習三：寫一個能夠印出 n 個 * 的函式（連結） 練習四：寫一個能回傳 n 個 * 的函式（同上連結） 練習五：判斷大小寫（連結） 練習六：回傳第一個大寫字母以及它的 index （連結） 練習七：回傳陣列裡面所有小於 n 的數的數量（連結） 練習八：回傳陣列裡面所有小於 n 的數的總和（連結） 練習九：回傳陣列裡面所有小於 n 的數（連結） 練習十：回傳陣列總和（連結） 綜合題目練習 Lv2 練習一：好多星星（連結） 練習二：好多星星 回傳版（連結） 練習三：好多星星 加強版（連結） 練習四：乘法表（連結） 練習五：九九乘法表（同上連結） 練習六：費式數列（連結） 練習七：字串反轉（連結） 練習八：大小寫互換 練習九：找出最小值 練習十：找出第 n 小的值 綜合題目練習 Lv3 練習一：排序 練習二：壓平陣列 練習三：印出聖誕樹（連結） 練習四：判斷圈圈叉叉勝負（連結） 練習五：判斷質數（連結）","link":"/javascript-js101-note/"},{"title":"React 環境設置 (CDN/CRA)","text":"安裝與設定環境 React 從一開始就被設計為逐步採用，可以根據需求來選擇使用 React 的範圍。 CDN 建立一個靜態的 index.html 檔案。 在 head 中載入三個 CDN，分別是 React、React DOM、Babel。 index.html 中寫一個 div，id 是root。 最後在&lt;body&gt; end tag 之前新增script區塊放置程式碼。 &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;React_CDN&lt;/title&gt; &lt;script src=\"https://unpkg.com/react@16/umd/react.development.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/babel-standalone@6.26.0/babel.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;script type=\"text/babel\"&gt; // React code will go here &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 目前已經載入寫作時穩定的版本： React - React 頂層的 API React DOM - adds DOM-specific methods The react-dom package provides DOM-specific methods that can be used at the top level of your app and as an escape hatch to get outside of the React model if you need to. Most of your components should not need to use this module. Babel - a JavaScript compiler that lets us use ES6+ in old browsers 整個 app 的進入點會是這個 div#root，已經是使用慣例。 現在，使用 ES6 的 class 來寫第一個 React 的程式，新增一個叫做 app 的 component。 class App extends React.Component &#123; //...&#125; 加入 render() 方法，這是 class component 唯一必須存在的 method，用來渲染 DOM 節點。 class App extends React.Component &#123; render() &#123; return ( //... ); &#125;&#125; 在 return 中，簡單放個 HTML 元素。要注意這邊放的類型並不是字串，所以不使用單引號或雙引號把內容包起來。這叫做 JSX，之後會談到更多。 class App extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello, I'm here&lt;/h1&gt; &#125;&#125; 最後，使用 React 提供的 DOM 渲染方法 render() 把 App 這個 class 創建到我們的 div#root 當中。 ReactDOM.render(&lt;App /&gt;, document.getElementById('root')) index.html 最後長這樣 &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;React_CDN&lt;/title&gt; &lt;script src=\"https://unpkg.com/react@16/umd/react.development.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/babel-standalone@6.26.0/babel.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; &lt;script type=\"text/babel\"&gt; class App extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello, I'm here&lt;/h1&gt; &#125; &#125; ReactDOM.render(&lt;App /&gt;, document.getElementById('root')) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 可以在瀏覽器看到內容就代表成功了： Local Environment (CRA/Create React App) CDN 引入 libraries 的方法並不是很有效率，也不容易維護，所幸 facebook 提供了create-react-app，它幫你在設定好在開發React App 前的所需的環境。 live server Webpack 自動編譯 React, JSX, and ES6, auto-prefix CSS 檔案 ESLint測試並提醒程式碼錯誤的地方 設定 create-react-app （app 名稱） 打開 terminal，跟著以下步驟安裝。回到你想安裝專案的上一層資料夾，確定一下 Node.js 版本是否在 5.2 或以上。 一、安裝 npx create-react-app create-react-app 二、進入專案資料夾，開始專案 cd create-react-appnpm start 專案檔案包含： 觀察專案的結構，可以看到 /public、/src 兩個資料夾，和node_modules、.gitignore、README.md、package.json 這幾個檔案。 在 /public 中，index.html 是我們重要的檔案，跟先前使用 CDN 建立的 index.html 非常相似，都有著 div#root，只是這次沒有載入任何 libraries 和程式碼。 /src 會放置我們所建立的 React 程式碼。 /src/App.js 看環境如何自動編譯，找到以下這行改看動試試更新程式碼及樣板。 To get started, edit &lt;code&gt;src/App.js&lt;/code&gt; 一旦更動程式碼發現 localhost:3000 自動更新樣板，這就是live server。 把 /src 資料夾中的檔案刪除，只留 index.css 和 index.js，不會爆掉。 三、在 index.js 中 import React、ReactDOM、CSS 檔案： import React from 'react'import ReactDOM from 'react-dom'import './index.css' 我們再建立 App component 一次。使用 CDN 方法時，我們有個&lt;h1&gt;元素，但現在我們試著在&lt;div&gt;上加上className取代class來引入樣式規則。這意味著我們正在 JavaScript 中攥寫我們的樣板，而非真實 HTML 檔案。 class App extends Component &#123; render() &#123; return ( &lt;div className=\"App\"&gt; &lt;h1&gt;Hello, I'm here&lt;/h1&gt; &lt;/div&gt; ) &#125;&#125; 四、以下是完整的 index.js，這次我們要把 Component 當作 React 的參數載入，這樣也就不需再 extend React.Component： import React, &#123; Component &#125; from 'react'import ReactDOM from 'react-dom'import './index.css'class App extends Component &#123; render() &#123; return ( &lt;div className=\"App\"&gt; &lt;h1&gt;Hello, I'm here&lt;/h1&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;App /&gt;, document.getElementById('root')) 五、打開瀏覽器 localhost:3000 看看，已經成功開始我們的 React 專案： Reference 參考連結","link":"/react-setting-cdn-and-creatreactapp/"},{"title":"Arrow function 解決了什麼問題？","text":"目的 將 this 鎖在 function 當中。 為了取代舊有的.bind()（.bind() 會綁定 this 到指定的 obj）。 適合情境 只要 function 內的 this 還要再往下傳的時候，就適合使用 arrow function。 Rules Rule 1 在 ES5 function 寫法時，this 指誰，要看被呼叫時是誰呼叫他。 Rule 2 箭頭函數當中的 this 是定義時的對象，而不是使用時的對象。arrow function 中沒有 this，this 指誰要看他身處在的環境 (function scope) 當中 this 指向誰 (回到 Rule 1)，也就是一定要有人在外層接起來，沒有接起來就會指向 global object，瀏覽器的執行環境中稱為 window。 Example 123456789101112131415161718192021222324252627282930313233let BMI = &#123; test: function () &#123; console.log('BMI.test', this) // BMI，由被呼叫時看是誰叫的。 function testtest () &#123; console.log('BMI.test &gt; testtest(ES5)', this) // 由被呼叫時看是誰叫的。testtest() 找不到是誰叫的 // 指向 window。 // 若要傳遞 this，解決方式是 // 在 BMI.test()設一個變數把 this 接起來 // eg. let that = this &#125; let testtest2 = () =&gt; &#123; console.log('BMI.test &gt; testtest2(ES6)',this) // 指向 BMI =&gt; 被鎖住哩！ &#125; testtest() testtest2() &#125;, test2: () =&gt; &#123; console.log('BMI.test2', this) // 指向 window，arrow function 沒有 this， // 往上一層又找不到，往上持續找到最上層是 window。 // 這樣的寫法，原本就是指向 window。 &#125;&#125;BMI.test()BMI.test2() 參考： MDN - 箭頭函式 PJ - [筆記] 談談 JavaScript 中的 “this” 和它的問題 Kuro - What’s THIS in JavaScript ? [中]","link":"/this-arrow-function-in-javascript/"},{"title":"透過複製陣列理解 JS 的淺拷貝與深拷貝 - JavaScript","text":"本篇文章翻譯自 How to clone an array in JavaScript - by Yazeed Bzadough on freeCodeCamp @medium，搭配 JS 的拷貝 by Kai @github 提及的概念，整理成筆記。 TL; TR 8. JSON.parse and JSON.stringify 是深拷貝。其他都是淺拷貝。 「call by reference」與「call by value」？ 基本型別 (Primitive Type) - number, string, boolean, null, undefined - 傳值 物件 (Objects) - array, function, object - 傳址 array/object 當中若含有複合型別時，此複合型別是 call by reference 而不是 by value。 「淺拷貝」與「深拷貝」的定義與差異？ 淺拷貝在複製 object 時，會參考到同一個物件，並沒有將此物件拷貝到並建立出新的關聯。 深拷貝在複製 object 時，會獨立出來不共用同一個記憶體位置，改動 newObject 時不會動到 oldObject。 這只是試看看能否用一個步驟就能深拷貝陣列的方式而寫的文章，網路上能找到其他更有趣的實作唷！ 更多深拷貝與淺拷貝的比較也可以參考 Larry Lu、ZHI-WEI jquery - $.extend() loadash - _.cloneDeep() 在 JavaScript 當中，很多方式能複製陣列。 1. Spread Operator・Shallow Copy 展開運算子・淺拷貝 自從 ES6 普及後，展開運算子（Spread Operator）已經成為最熱門的方法，它有著簡潔的語法（Syntax），所以若你使用 React、Redux 這樣的函式庫時會發現它神好用。 const numbers = [1, 2, 3];const numbersCopy = [1, 5, 6, ...numbers];// (6) [1, 5, 6, 1, 2, 3] 注意事項：對多維陣列來說，這不是安全的複製。因為 array/object 是 copied by reference 而不是 by value。 [ O ] 基於剛剛的程式碼，單維陣列可以這樣寫： numbersCopy.push(4);console.log(numbers, numbersCopy);// [1, 2, 3] and [1, 5, 6, 1, 2, 3, 4]// numbers 是一個獨立陣列，沒有副作用 [ X ] 假設是多維陣列的情況： const nestedNumbers = [[1], [2]];const numbersCopy = [...nestedNumbers];numbersCopy[0].push(300);console.log(nestedNumbers, numbersCopy);// [[1, 300], [2]]// [[1, 300], [2]]// 兩者會同時改變，因為是它們是根據同一個記憶體位址 2. Good Old for() loop・Shallow Copy 好用的老方法 for() loop・淺拷貝 我猜 for() loop 最不受歡迎，因為現在有其他很多新潮的函式可以選擇。 撇除操縱陣列要注意的原則， for() loop 能夠達成目的。 Pure / impure declarative / imperative const numbers = [1, 2, 3];const numbersCopy = [];for (let i = 0; i &lt; numbers.length; i++) &#123; numbersCopy[i] = numbers[i];&#125; 注意事項：對多維陣列來說，這不是安全的複製。你使用 = 運算子，會指向該 array/object 的記憶體位置 （ copied by reference 而不是 by value）。 [ O ] 基於剛剛的程式碼，單維陣列可以這樣寫： numbersCopy.push(4);console.log(numbers, numbersCopy);// [1, 2, 3] and [1, 2, 3, 4]// numbers 沒副作用 [ X ] 假設是多維陣列的情況： const nestedNumbers = [[1], [2]];const numbersCopy = [];for (let i = 0; i &lt; nestedNumbers.length; i++) &#123; numbersCopy[i] = nestedNumbers[i];&#125;numbersCopy[0].push(300);console.log(nestedNumbers, numbersCopy);// [[1, 300], [2]]// [[1, 300], [2]]// 兩者會同時改變，因為是它們是根據同一個記憶體位址 3. Good Old while() Loop (Shallow copy) 好用的老方法 while() loop・淺拷貝 和 for() 相同，impure、imperative，一樣達成目的。 const numbers = [1, 2, 3];const numbersCopy = [];let i = -1;// 從 -1 開始，複製的值才會指向正確的 indexwhile (++i &lt; numbers.length) &#123; // 變數 i 先 +1 後才比對是否符合條件 numbersCopy[i] = numbers[i];&#125; 注意事項：使用 = 運算子，會指向該 array/object 的記憶體位置 （ copied by reference 而不是 by value）。 [ O ] 基於剛剛的程式碼，單維陣列可以這樣寫： numbersCopy.push(4);console.log(numbers, numbersCopy);// [1, 2, 3] and [1, 2, 3, 4]// numbers 沒副作用 [ X ] 假設是多維陣列的情況： const nestedNumbers = [[1], [2]];const numbersCopy = [];let i = -1;while (++i &lt; nestedNumbers.length) &#123; numbersCopy[i] = nestedNumbers[i];&#125;numbersCopy[0].push(300);console.log(nestedNumbers, numbersCopy);// [[1, 300], [2]]// [[1, 300], [2]]// 兩者會同時改變，因為是它們是根據同一個記憶體位址 4. Array.map (Shallow copy) 內建的陣列操縱方法 Array.map 映射．淺拷貝 回到現代化的方式，可以使用 map 方法。根據數學理論，其實 Array.map 的概念是，保有原結構下，將一個集合轉成另一個集合（map is the concept of transforming a set into another type of set, while preserving structure.）。 換句話說就是：Array.map 每次都會回傳一個和原陣列長度相同的新陣列。 假設現在要寫一個 numbers 陣列，數字全部乘以 2 的寫法： const numbers = [1, 2, 3];const double = x =&gt; x * 2;numbers.map(double); 那複製陣列呢？ 沒錯，這篇文章的確是要講如何複製陣列。在 Array.map 方法，要複製陣列只要「回傳」你的元素即可： const numbers = [1, 2, 3];const numbersCopy = numbers.map(x =&gt; x); 若用數學理論的層面來解讀，(x) =&gt; x 稱為 identity。無論是否有帶參數都直接回傳元素。 map(identity) 本身就是複製一個清單。 const numbers = [1, 2, 3];const identity = x =&gt; x;const numbersCopy = numbers.map(identity);console.log(numbersCopy);// [1, 2, 3] ，numbers 沒副作用 注意事項：array/object 當中若含有複合型別時，此複合型別是 call by reference 而不是 by value。 5. Array.filter (Shallow copy) 內建的陣列操縱方法 Array.filter ．淺拷貝 Array.filter 會回傳一個陣列，如同 map，但它不保證回傳與原陣列相同的長度。 濾出偶數：（原陣列長度是 3，而輸出的新陣列長度是 1） [1, 2, 3].filter(x =&gt; x % 2 === 0);// [2] 所以假設你的 filter 過濾的條件只要是 true 都回傳，那就等同於複製了。 const numbers = [1, 2, 3];const numbersCopy = numbers.filter(() =&gt; true); 陣列當中的每一個元素都達成條件，所以全部都會被回傳到一個新陣列。 注意事項：array/object 當中若含有複合型別時，此複合型別是 call by reference 而不是 by value。 6. Array.reduce (Shallow copy) 內建的陣列操縱方法 Array.reduce ．淺拷貝 使用 reduce 來複製陣列不是很優，雖然一樣可以解決問題，但 reduce 可以做到比複製陣列更有力量的事。 const numbers = [1, 2, 3];const numbersCopy = numbers.reduce((newArray, element) =&gt; &#123; newArray.push(element); return newArray;&#125;, []); Array.reduce 在迭代陣列前可以預設一個初始值。 範例中的初始值是空陣列，我們會在迭代原陣列時把單次跑到的「元素」新增至新陣列，而新陣列會被「回傳」，成為下一次迭代的初始值。 注意事項：array/object 當中若含有複合型別時，此複合型別是 call by reference 而不是 by value。 7. Array.slice (Shallow copy) 內建的陣列操縱方法 Array.slice ．淺拷貝 Array.slice 方法會根據提供的「開始、結束 的 index」回傳陣列的淺拷貝。 如果你只想複製陣列的前三個元素： [1, 2, 3, 4, 5].slice(0, 3);// [1, 2, 3]// 從 index 0 開始, index 3 結束 如果你想複製全部陣列，直接不給參數即可： const numbers = [1, 2, 3, 4, 5];const numbersCopy = numbers.slice();// [1, 2, 3, 4, 5] 注意事項：array/object 當中若含有複合型別時，此複合型別是 call by reference 而不是 by value。 8. JSON.parse and JSON.stringify (Deep copy) ．深拷貝 JSON.stringify：將物件轉字串。 JSON.parse：將字串轉物件。 結合兩者可以達成深拷貝，複製多維陣列，可是會有效能上的問題。 const nestedNumbers = [[1], [2]];const numbersCopy = JSON.parse(JSON.stringify(nestedNumbers));numbersCopy[0].push(300);console.log(nestedNumbers, numbersCopy);// [[1], [2]]// [[1, 300], [2]]// 兩個陣列是獨立的，互不影響！ 缺點：只能套用在拷貝轉成 JSON 格式的物件上，像 function 就沒辦法。 9. Array.concat (Shallow copy) 內建的陣列操縱方法 Array.concat ．淺拷貝 Array.concat： 合併 a 陣列與 b 陣列的值。 [1, 2, 3].concat(4); // [1, 2, 3, 4][1, 2, 3].concat([4, 5]); // [1, 2, 3, 4, 5] 如果是給一個空陣列作為引數，淺拷貝會直接中斷（return）。 [1, 2, 3].concat(); // [1, 2, 3][1, 2, 3].concat([]); // [1, 2, 3] 注意事項：array/object 當中若含有複合型別時，此複合型別是 call by reference 而不是 by value。 10. Array.from (Shallow copy) 內建的陣列操縱方法 Array.from ．淺拷貝 Array.from：可以將任何可迭代的物件轉成陣列。因為陣列本身就是物件的一種，所以只要給一個陣列作為引數，就會回傳一個淺拷貝。 const numbers = [1, 2, 3];const numbersCopy = Array.from(numbers);// [1, 2, 3] 注意事項：array/object 當中若含有複合型別時，此複合型別是 call by reference 而不是 by value。","link":"/javascript-deep-copy-swallow-copy/"},{"title":"談一下 CSS Specificity","text":"CSS 剛開始學習容易上手 往後卻難以維護 CSS 較鬆散， 非常仰賴攥寫的順序 但這些都比不上不懂 Specificity 的恐怖！XDDD Specificity 看不懂？ Specificity 譯為優先級、特定度、權重 註：Ｏ’reily 翻譯為特定度；MDN 翻譯為優先級；有些翻譯為權重。本文一律以「權重」表示 Specificity。 Specificity 幹嘛的？ 決定你的元素優先吃哪一個樣式的其中一個因素！ Chris 這篇文章解釋得很清楚：Cascade 動作是由 Specificity 和 Ruleset order 作用，決定要套用的 CSS。 換句話說 先比權重，再比順序！ 當兩個 CSS 宣告同時作用在一個元素時： 權重高 優先生效！ 相同權重時 後寫的 CSS 會覆蓋先寫的 CSS 透過範例了解一下剛剛在說什麼 我們有一個區塊元素 div 包覆著一個 button 。 這個 button 的 class 有 button（基本按鈕的樣式）、button__disabled（無法點擊的狀態樣式）。 HTML &lt;div&gt; &lt;button class=\"button__disabled button\"&gt;Click me&lt;/button&gt;&lt;/div&gt; CSS .button &#123; padding: 10px 20px; font-size: 32px; border-radius: 3px; border: none; /* notice below 被 button__disabled 的樣式覆蓋了 */ background: #eee; color: #333; cursor: pointer;&#125;.button__disabled &#123; background: #ccc; color: #999; cursor: not-allowed;&#125; example - try it 透過範例可以了解兩件事： 決定要套用樣式的基礎並不在於我們在 HTML Element 上引用 Class 的順序，而是，該 class 在我們攥寫 CSS 樣式表當中的順序。 若在同樣都只有一個 class 選擇器的狀況下（.button、.button__disabled） 後面寫的樣式宣告（.button__disabled） 在 CSS 樣式表中，較前面的內容有指定同一個 HTML Element 的選取器（.button） 並且攥寫了重複的內容時（background、color、cursor） 後面寫的樣式宣告（.button__disabled）會優先被套用，覆蓋掉原本的樣式（.button） 權重計算的基本規則 如上圖，檢查對應的出現的次數、由左向右比較，看 W3C 的定義，其實是從 id=&gt; class =&gt; element，檢查完再去看是否有設定 important 行內樣式。但我把它們集合起來畫成一張對應的表，比較方便理解、查閱跟記憶。 我的 CSS Specificity 的 CheatSheet： specificity 條件 1-0-0-0-0 !important 0-1-0-0-0 HTML Element 中的行內樣式， style=&quot;&quot; 0-0-1-0-0 #id 0-0-0-1-0 .class, :pseudo class, attribute 0-0-0-0-1 element (h1), ::pseudo element 0-0-0-0-0 *, +, &gt;, ~, 空格, :not() 例外 :not :not 雖是偽類，可是其無任何權重，但 :not(.class) 依據參數還是會增加權重 有趣的小工具：CSS權重計算機 實例 一個新手容易踩的雷：使用 id 選取器，等專案越做越大時，開始有製作新的 table 需求時… #content table &#123; &#125;/** * 不，我寫的東西無法生效 :( */.my-new-table &#123; &#125; 命名沒表現任何語意，看不來是何種 table 使用 id 選取器則侷限了這個 table，只能套用在這個名為 content 的 id 中 通常會有兩種做法 重構，移除 id 為了生效，算了不管它了！我要以較高的權重覆蓋它！ 因為若專案較大時，有時無法確定移除 id 對整個專案的影響 使出我的覆蓋技能 #content table &#123; &#125;#content .my-new-table &#123; /* 耶，可以看到我的樣式了！ */ &#125; 結束這回合…了嗎？ 開始進入惡性循環，權重只要一開始疊的高，以後只能越設越高！ !important 該死？ “Rules are the children of principles.” - Jamie Mason When to use !important properly? 有些開發者都覺得 !important 是萬惡的，若 !important 真的如此該死，當初又何必設計它的存在呢？ 其實只要： 了解使用目的！確保你的樣式在 global 都要能 work而不是為了覆蓋（fix）你改不掉的樣式 Keep It Low at All Times 永遠保持最低的權重，這就是原則！ How to keep it low? 絕對不要使用 ID ID 辦得到的事，Class 全部都可以 ID 不能重複使用就算了，還會增加權重 若真無他法一定要使用的話： hack: [id=&quot;your-id&quot;] (attribute 0-0-1-0) （等同於 class 的權重及選取，但可讀性就較低了，不建議不建議不建議！） 選取器不要巢過了頭 建議不要超過三層 不要限定你的選擇器 .nav {} 可以做到的事，不要用 ul.nav {} 盡可能地使用 class 並且保持低權重，讓大家都有相同的權重，公平！ YA！CSS 又 變瘦 變輕了！（是權重不是檔案大小，囧） 理解完，考自己一下，你應該會笑：） 有趣的圖 Reference Spec Calculating a selector’s specificity - W3C Book CSS 重構 - Steve Lindstrom 著、陳健文 譯（好想工作室有這本書） Internet Day20：小事之 CSS 權重 (css specificity) - iT邦幫忙 cssspecificity.com CSS guildlines [Hacks for dealing with specificity - CSS Wizardry](","link":"/css-specificity/"},{"title":"在 JavaScript 中，Var、Let、Const 的差異？","text":"Var 露出去的變數 i： for(var i = 0; i&lt;10; i++) &#123; console.log(i)&#125;console.log(i) // undefined function scope：function 外就存取不到變數 i。 function printing()&#123; for(var i = 0; i&lt;10; i++) &#123; console.log(i) &#125;&#125;printing()console.log(i) // Uncaught ReferenceError: i is not defined IIFE (immediately invoked function expression) 立即執行函式：將變數 i 鎖在 function scope 中。 (function ()&#123; for(var i = 0; i&lt;10; i++) &#123; console.log(i) &#125;&#125;)() Let block scope：block {} 外就存取不到變數 i。 for(let i = 0; i&lt;10; i++) &#123; console.log(i)&#125;console.log(i) // Uncaught ReferenceError: i is not defined Const 如果在一段程式碼中，確定不會更動變數的值，就使用 const 來宣告變數。 const dog=&#123; age: 3&#125;dog.age = 5dog = &#123; name: 'biko'&#125; // Uncaught TypeError: Assignment to constant variable. 可以改變物件下的屬性（property），而不能重新把變數 dog 指向一個新的物件。 Reference Javascript variables; should you use let, var or const?","link":"/differences-among-var-let-const/"},{"title":"開發者一定要知道的 GIT tricks","text":"修改了某些檔案，一次只 commit 其中某幾個檔案 假設我們在開發的過程當中，做了某些檔案的修改。 git status# 看到以下的狀態On branch developChanges not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be commited) (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory)modified: document.jsonmodified: package-lock.jsonmodified: package.jsonmodified: src/app/app.component.htmlmodified: src/app/app.component.tsmodified: src/app/app.module.tsmodified: src/index.htmlmodified: src/styles.cssno changes added to commit (use \"git add\" and/or \"git commit -a\") 可是我只希望部分檔案加入 staging area，比如寫 component 時很好用，現在只希望加入 src/app/app.component 開頭的兩個檔案： src/app/app.component.html、src/app/app.component.ts。 # 原本要這樣加入git add src/app/app.component.html src/app/app.component.ts# 現在只要這樣寫git add src/app/app.component-* 想加入相同檔案類型的語法就是反過來，比如加入 .html 檔案： git add *.html 下 git log 時，提高可讀性，顯示時間、下 commit 的人 在使用 GIT 的時候，常常需要檢視我們的 commit 紀錄，而查看紀錄的語法是 git log。 一般來說，我們在 terminal下 git log 會看到以下訊息： commit 9a7f06bd416decd8ec8463248d159cde67c48c82Author: Askie &lt;youremail@gmail.com&gt;Date: Fri Oct 12 13:05:45 內建呈現的格式提供的資訊並不符合每天查閱的需求，所以接下來會教你會加入一個 alias ，指向新的設定。 # 在專案底下查看 git 設定檔vim ~/.gitconfig # .gitconfig 檔案[alias] lg = log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit --branches git lg 可以看到有顯示以下資訊（請忽略新手還亂亂的 commit 的訊息，以及把顏色改掉了看不出來這件事&gt;//&lt;）： SHA1 HEAD 指向哪個 commit 分支名稱 Commit message 合併分支的流程以圖形介面呈現 多久以前 commit 誰做了這個 commit 更多設定 alias 的內容可以參考為你自己學 Git-其它方便的設定。 本文章內容是參考 egghead.io 的 Juri Strumpflohner 所開的 Productive Git for Developers 課程內容包含下面的情境，想學習的可以去訂閱唷！ 修改了某些檔案，一次只 commit 其中某幾個檔案 下 git log 時，提高可讀性，顯示時間、commit 的人 不小心把 commit 下在 Master，如何移動某些 commits 到另一個新分支？ 取 master 最新的 commit 內容，搬到現在正在開發中的 feature branch 將本地端有 rebase 過的分支 push 到遠端（使用 --force-with-lease） 在提交要給夥伴 review、merge 前，怎樣整理好我們的 git branch 利用 Git Autosquash 自動清理我們的 feature branch（有時候開發途中會發現其他小問題，會產生一些 fix 這種可讀性低的 commits） 整合數個 commits 成一個 commit，並且 merge 到 master message 打錯了！只修改最後一次 commit 的 message 少 commit 一個要的檔案！補到最後一次 commit 當中 取消最後一次 commit 並且將它切成兩個 從 branch 當中永遠移除某個 commit（使用 git reset） 將不小心 push 到遠端 Repository 的 commit 取消 暫存一些正在做的事情，因為我現在需要跳到其他分支","link":"/git-commit-and-git-log-alias-protips/"},{"title":"五個小技巧讓你寫出更好的 JavaScript 條件語句（翻譯）","text":"1. 使用 Array.includes 來處理多重條件 // 原始寫法function test(fruit) &#123; // 條件語句 if (fruit === \"apple\" || fruit === \"strawberry\") &#123; console.log(\"red fruit\"); &#125;&#125; 乍看之下，寫法沒什麼錯誤。可是當我們有更多紅色水果的選項時，如 cherry（櫻桃）和 cranberries（蔓越莓），難道我們要增加更多的 || 邏輯運算子來判斷？ 我們用 Array.includes 來改寫一次上面的判斷式： // 改寫後function test(fruit) &#123; // 將選項提取出來，放入陣列當中 const redFruits = [\"apple\", \"strawberry\", \"cherry\", \"cranberries\"]; if (redFruits.includes(\"apple\")) &#123; console.log(\"red fruit\"); &#125;&#125; 將選項、可能的答案提取出來，放入陣列 red fruits 當中。這樣寫的話，程式碼看起來更加簡潔。 2. 減少巢狀，儘早回傳（ return） 這裏使用上面的程式碼內容來接續下面的範例，新增兩個條件。 如果參數 fruit 沒有值，回傳錯誤（ error）。 如果數量超過 10 的話，印出一個訊息。 // 原始寫法，寫法一function test(fruit, quantity) &#123; const redFruits = [\"apple\", \"strawberry\", \"cherry\", \"cranberries\"]; // 判定一：fruit 必須有值 if (fruit) &#123; // 判定二：fruit 必須是紅色的 if (redFruits.includes(fruit)) &#123; console.log(\"red fruit\"); if (quantity &gt; 10) &#123; // 判定三：fruit 數量必須大於 10 console.log(\"big quantity\"); &#125; &#125; &#125; else &#123; throw new Error(\"No fruit!\"); &#125;&#125;// 測試結果test(null); // 錯誤：沒有水果的值！test(\"apple\"); // 印出 red fruittest(\"apple\", 20); // 印出 red fruit、big quantity 以上程式碼，已經加入了： 1 個 if/else 的條件判斷，篩選掉無效的內容。 3 個巢狀條件判斷（判定一、判定二、判定三）。 對我個人而言，有一個基本通則，那就是「減少巢狀，儘早回傳」： // 改寫後，寫法二function test(fruit, quantity) &#123; const redFruits = [\"apple\", \"strawberry\", \"cherry\", \"cranberries\"]; // 判定一：無效的值就直接跳出程式，拋出 error if (!fruit) throw new Error(\"No fruit!\"); // 判定二：fruit 必須是紅色的 if (redFruits.includes(fruit)) &#123; console.log(\"red fruit\"); // 判定三：fruit 數量必須大於 10 if (quantity &gt; 10) &#123; console.log(\"big quantity\"); &#125; &#125;&#125; 改寫程式碼後，現在只有一層的巢狀判斷式。尤其當你有很長的判斷條件時，這樣的 Coding Style 很棒（想像一下，你捲軸需要捲到很後面才知道 else 區塊做了什麼處理。難以閱讀，不帥！） 透過轉換判斷式寫法、儘早回傳，可以更進一步的精簡巢狀 if，來看下面 判斷式二 是如何實現的： // 改寫後，寫法三function test(fruit, quantity) &#123; const redFruits = [\"apple\", \"strawberry\", \"cherry\", \"cranberries\"]; // 判定一：無效的值就直接跳出程式，拋出 error if (!fruit) throw new Error(\"No fruit!\"); // 判定二：fruit 不是紅色的，就直接跳出程式 if (!redFruits.includes(fruit)) return; console.log(\"red\"); // 判定三：fruit 數量必須大於 10 if (quantity &gt; 10) &#123; console.log(\"big quantity\"); &#125;&#125; 將判斷式二改成上面的寫法，我們的程式碼就不再這麼「巢」了！假設我們有很長的程式邏輯，並且想要在不滿足條件時中斷程式的進行，這樣的寫法很有效率、易讀。 然而，其實也沒什麼硬性規定該如何寫，一切依使用情境而定，問問自己：「這個寫法套用在目前的狀況有增加可讀性嗎？」 對我來說，我應該會選擇寫法二（只有一層的巢狀結構），原因在於： 程式碼簡潔、直覺，有一層的 if 判定使得邏輯更清晰 反轉程式碼在讀的時候會產生思考流程、增加認知負擔 因此，「減少巢狀，儘早回傳」是原則，但也不要過度使用。 以下有針對這個主題討論的文章及 StackOverflow 討論，有興趣的話可以看一下： Avoid Else, Return Early by Tim Oxley StackOverflow discussion on if/else coding style 3. 函式使用預設值、解構 我猜你應該很熟悉下面這段程式碼，因為我們總是在確認 null / undefined 的值，是的話就給一個預設值。 // 我們可能熟悉的寫法function test(fruit, quantity) &#123; if (!fruit) return; // 若數量是 falsy value，將預設值設定為 1 const q = quantity || 1; console.log(`We have $&#123;q&#125; $&#123;fruit&#125;!`);&#125;// 測試結果test(\"banana\");test(\"apple\", 2); 事實上，在 function 針對參數（parameter） q 先設定預設值，就可以不用在程式碼區塊定義 變數 q。 // 給預設值的寫法function test(fruit, quantity = 1) &#123; if (!fruit) return; console.log(`We have $&#123;q&#125; $&#123;fruit&#125;!`);&#125;// 測試結果test(\"banana\");test(\"apple\", 2); 更簡單、直覺了不是嗎？記得函式都可以設定每個參數的預設值，所以我們也可以幫參數 fruit 設定預設值，如 function test(fruit = 'unknown', quantity = 1)。 那假設 fruit 是物件怎麼辦？ // fruit 是物件的可能寫法function test(fruit) &#123; if (fruit &amp;&amp; fruit.name) &#123; // 若有值就印出水果名稱 console.log(fruit.name); &#125; else &#123; console.log(\"unknown\"); &#125;&#125;// 測試結果test(undefined); // unknowntest(&#123;&#125;); // unknowntest(&#123; name: \"apple\", color: \"red\" &#125;); // apple 上面的範例中，我們希望水果名稱有值時就把它印出來，沒值就印出 unknown。其實，我們可以透過設定函式預設值與解構來減少 fruit &amp;&amp; fruit.name 這種條件判定。 // 透過解構賦予參數預設值function test(&#123; name &#125; = &#123;&#125;) &#123; console.log(name || \"unknown\");&#125;// 測試結果test(undefined); // unknowntest(&#123;&#125;); // unknowntest(&#123; name: \"apple\", color: \"red\" &#125;); // apple 因為函式只需要用到物件 fruit 的屬性 name，所以我們可透過 {name} 將其解構出來使用，函式當中就可以拿 name 當作變數來參照，取代 fruit.name 寫法。 我們解構賦值時，至少要設定空物件 {} 為預設值。否則會出現這個錯誤：Uncaught TypeError: Cannot destructure propertynameof 'undefined' or 'null'.。 如果你不介意使用第三方函式庫的話，那麼我這裡有兩個方法可減少 null 的檢查： 使用 Lodash - get function 使用 Facebook 開源的 idx 函式庫 （需要 Bebeljs 轉譯） Lodash get function： _.get(object, path, [defaultValue]); Lodash 使用方法： function test(fruit) &#123; // 若有值就印出水果名稱，否則採用預設值 'unknown' console.log(_.get(fruit, \"name\", \"unknown\"));&#125;// 測試結果test(undefined); // unknowntest(&#123;&#125;); // unknowntest(&#123; name: \"apple\", color: \"red\" &#125;); // apple 你可以在 Codepen 玩玩這段程式碼。如果你是 Functional Programming 愛好者，你可以把 Library 選項改成 Lodash fp（方法會改成 ._getOr），引數順序會從 a, b, c 改成 c, b, a。這裡有我的 FP v4.0 - demo。 Lodash FP 使用方法： function test(fruit) &#123; // 若有值就印出水果名稱，否則採用預設值 'unknown' console.log(_.getOr(\"unknown\", \"name\", fruit));&#125;// 測試結果test(undefined); // unknowntest(&#123;&#125;); // unknowntest(&#123; name: \"apple\", color: \"red\" &#125;); // apple 4. 相較於 Switch，Map / Object 是個好選擇 下面範例想要根據水果顏色，印出水果： function test(color) &#123; // 使用 switch case，根據水果顏色印出水果 switch (color) &#123; case \"red\": return [\"apple\", \"strawberry\"]; case \"yellow\": return [\"banana\", \"pineapple\"]; case \"purple\": return [\"grape\", \"plum\"]; default: return []; &#125;&#125;// 測試結果test(null); // []test(\"yellow\"); // ['banana', 'pineapple'] 程式碼邏輯雖沒錯，卻非常冗贅。相同的結果，可以利用物件實體語法（object literal），以清楚的語句來達成。 const fruitColor = &#123; red: [\"apple\", \"strawberry\"], yellow: [\"banana\", \"pineapple\"], purple: [\"grape\", \"plum\"]&#125;;function test(color) &#123; return fruitColor[color] || [];&#125;// 測試結果test(null); // []test(\"yellow\"); // ['banana', 'pineapple'] 另一個選擇是 Map 達成相同結果： const fruitColor = new Map() .set(\"red\", [\"apple\", \"strawberry\"]) .set(\"yellow\", [\"banana\", \"pineapple\"]) .set(\"purple\", [\"grape\", \"plum\"]);function test(color) &#123; return fruitColor.get(color) || [];&#125;// 測試結果test(null); // []test(\"yellow\"); // ['banana', 'pineapple'] Map 是 ES2015 起來有的物件型別，讓你可以去儲存成對的 key 及 value。 那麼，難道我們該捨棄使用 Switch 嗎？別讓自己受限，就我個人而言，我會盡可能地使用物件實體語法（object literal），但我不會把規則定死，老話一句，一切只要適用於情境即可。 Todd Motto 寫過一篇文章在討論 switch 和 物件實體語法（object literal），有興趣可以看一下。 TL; DR; 重構語法 重構資料結構後，可以透過 Array.filter 達成相同結果： const fruits = [ &#123; name: \"apple\", color: \"red\" &#125;, &#123; name: \"strawberry\", color: \"red\" &#125;, &#123; name: \"banana\", color: \"yellow\" &#125;, &#123; name: \"pineapple\", color: \"yellow\" &#125;, &#123; name: \"grape\", color: \"purple\" &#125;, &#123; name: \"plum\", color: \"purple\" &#125;];function test(color) &#123; return fruits.filter(f =&gt; f.color === color);&#125; 總是有超過一種方式可以達成相同結果，以上已經提到 4 種程式範例，寫程式真的很有趣吧，呵呵。 5. 用 Array.every 和 Array.some 應用於全部與局部條件 最後一個技巧是利用 JavaScript 提供 Array 的新方法（但也不是那麼新啦）來減少程式碼的行數。來看看以下的程式碼，我們來檢查全部的水果是不是紅色的？ 檢查全部水果是否都是紅色的？ // 原本可能這樣寫const fruits = [ &#123; name: \"apple\", color: \"red\" &#125;, &#123; name: \"banana\", color: \"yellow\" &#125;, &#123; name: \"grape\", color: \"purple\" &#125;];function test() &#123; let isAllRed = true; // 條件：全部的水果必須是紅色的 for (let f of fruits) &#123; if (!isAllRed) break; isAllRed = f.color === \"red\"; &#125; console.log(isAllRed); // false&#125; 這樣的程式碼太長了，可以使用 Array.every 來減少程式碼： // 檢查全部水果是否符合條件const fruits = [ &#123; name: \"apple\", color: \"red\" &#125;, &#123; name: \"banana\", color: \"yellow\" &#125;, &#123; name: \"grape\", color: \"purple\" &#125;];function test() &#123; // 條件：全部的水果必須是紅色的 const isAllRed = fruits.every(f =&gt; f.color === \"red\"); console.log(isAllRed); // false&#125; 更清楚了吧？另一個相似的做法，如果我們想要檢查任一種水果是不是紅色的，可以用 Array.some 一行解決！ 檢查任一種水果是紅色的？ // 檢查任一種水果是否符合條件const fruits = [ &#123; name: \"apple\", color: \"red\" &#125;, &#123; name: \"banana\", color: \"yellow\" &#125;, &#123; name: \"grape\", color: \"purple\" &#125;];function test() &#123; // 條件：只要其中有一種水果是紅色的 const isAnyRed = fruits.some(f =&gt; f.color === \"red\"); console.log(isAnyRed); // true&#125; 結論 我們一起寫出更多易讀的程式吧，希望你看完這篇文章能有所獲。 那就這樣囉，Happy Coding! 覺得文章還不賴的話，訂閱我的 Twitter Reference 原文：5 Tips to Write Better Conditionals in JavaScript 參考：[五个小技巧让你写出更好的 JavaScript 条件语句](","link":"/javascript-good-condition-statement/"},{"title":"千人活動的備餐原則 - 根據 kerl lin 大大文章所整理的待辦清單","text":"完全參考至 （千人活動的便當該如何準備？——Karl Lin）並加以整理，詳情可以連結至原作者文章。 什麼都行，最重要的是：絕對不能「食物中毒」！ 辦活動訂午餐，可以不好吃，可以又貴份量又少吃不飽，可以剩一堆廚餘，但**絕對絕對不能食物中毒**。 避免食物中毒的措施 謹慎挑選便當業者。 不要太早送到活動場地。 讓便當業者自己送餐（因為他們知道不同天氣下怎樣送便當能避免變質）。 不要使用 UberEATS 或 LaLaMove（因為他們不是食物外送專家）。 每種口味的便當預留一份放冰箱（因為如果最後食物中毒，至少有保留證據能釐清問題是便當業者或是活動方）。 食物中毒的可能因素 前：在廚房製作時就出問題。 中：運送過程中，天氣太熱造成變質。 後：過早送來活動會場，活動場地保存過程有問題。 挑選便當業者的原則 並不是隨便挑一間喜歡或吃過的餐廳、自助餐就可以！ 有沒有大量出餐的經驗？ 有經驗的業者會： 食安有保障：備料過程、食材選擇都會特別注意。 送餐準時：有大量出餐過，才抓得準時間。 實際去廚房逛過一次了嗎？ 如果不知道什麼是「好」廚房，先去看復興空廚、原味廚房、糧心廚房這類業界知名的，以它們作為標準。 是否有相關食安證照呢？ 例如：HACCP。 飲食屬性 除了「食物中毒」，並屏除「挑食狀況」以外，有些會因為身體或宗教因素而不能吃「海鮮、蠶豆」等食物，所以仔細觀察大型活動的便當內容物，通常不會看到「海鮮、蠶豆、豬肉」等食材。找到專業的便當業者，也可以稍微提醒他們一下。 吃飽、吃得開心的小訣竅 觀察活動參與者的「年齡、性別分布」，提供給餐飲業者參考。 會影響份量跟口味控制。 查看天氣預報。 天氣很熱，誰想吃咖哩？ 怎麼得知參與者有沒有吃開心？ 計算每次活動的「廚餘重量」。 藉此知道會眾有沒有把便當吃光光，累積個幾場活動就有比較、有經驗了。 餐點數量 辦活動就會有報到率的問題，所以量的控制注意： 根據過去活動或類似活動的報到率來計算便當數量。 千萬不要一千人報名，活動就訂一千份，一定會多出一堆。 多日活動：第一天和第二天報到率通常不同。 規定「幾點前報到才要便當吃」的措施。 提升報到率，避免便當剩餘浪費。 通常便當業者會接受，活動當天某時間點前修改 N% 的便當量，詢問業者能接受的「修改時間點」、「修改比例範圍」。 準備好「如果少訂（人數多於便當數量）」的備案。 某個時間點之後，開放「吃第二個便當」。 如果數量有多，可以解決便當剩餘浪費。 其他 如果便當真的多了太多，除了丟掉以外，有沒有其他處理方式？ 假設是在學校辦活動，可以直接敲宿舍同學拿免費便當； 或是聯絡社福機構？ 也要事先安排好人力來處理這件事。 餐飲是件很專業的事情，這邊提到的只是一小部分！ 放餐點的流程、 收廚餘的動線安排、 下午茶的時段和擺盤，背後都有許多眉角 更重要的並非條列式的一項項背起來，而是「細心、同理心、觀察力」。","link":"/meal-box-preperation-for-big-activity/"},{"title":"關於 Webpack，它是什麼？能夠做什麼？為什麼？怎麼做？— freeCodeCamp 的筆記","text":"關於 Webpack Webpack 是什麼？ 它是一個「打包工具」。將眾多模組與資源打包成一包檔案，並編譯我們需要預先處理的內容，變成瀏覽器看得懂的東西，讓我們可以上傳到伺服器。 前端日新月異，我們寫的內容已不只是寫 HTML、CSS、JavaScript 單純的檔案。前端出現了許多預處理工具及框架，預處理工具如 PUG、SASS、Babel；框架如 Vue、React。不過瀏覽器並看不懂我們寫的預處理內容，每每都需要透過編譯才能使用，也因此出現了自動化工具，Webpack、Gulp、Grunt、Parcel、Browserify…等。 Webpack 能夠做什麼？為什麼？ 適合用在大型的應用程式。因為大型的應用程式需要管理眾多不同類型的檔案，使用起來相對有感。 打包（Bundle）多個 .js 檔案成單一檔案。 你可以寫模組化的 JavaScript，你不再需要在 HTML 中引入每個 JavaScript 檔案（&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;），如果有眾多的 .js 檔案，可以透過 Webpack 來設定。 使用 NPM Packages 撰寫 JavaScript ES6 或以上 需要 babel 協助轉譯 最小化、優化程式碼 編譯 LESS 或 SCSS 成 CSS 使用 HMR（Hot Module Replacement） 包含任何類型的檔案到 JavaScript CommomJS、AMD、ES6 Modules、CSS、Images、JSON、Coffeescript、LESS 更多．．．． 安裝 先確定有沒有安裝 node： node -v 初始化 npm，將會在專案中產生 package.json。-y 會將需要回答的問題一次性略過， package.json 中，日後可以修改。 npm init -y .gitigonore 加上 node_modules，避免肥大的模組們被 GIT 追蹤。 node_modules package.json 新增 private 屬性，因為是自己練習用，不希望 NPM 被意外發布，詳情請參考 NPM 官方文件。 \"private\": true 安裝 Webpack，--save-dev 表示相依於開發模式而已，而發布為產品時不需要也沒關係： npm install --save-dev webpack webpack-cli 完成後，檢視你的 package.json 的 devDependencies 屬性應該會長這樣： // package.json&#123; \"name\": \"webpack-demo-app\", \"version\": \"1.0.0\", \"private\": true, \"description\": \"透過練習了解 Webpack 解決的事情，並在沒使用 Webpack 的專案試著導入 Webpack。\", \"main\": \"index.js\", \"scripts\": &#123;&#125;, \"repository\": &#123; \"type\": \"git\", \"url\": \"git+https://github.com/Colt/webpack-demo-app.git\" &#125;, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"bugs\": &#123; \"url\": \"https://github.com/Colt/webpack-demo-app/issues\" &#125;, \"homepage\": \"https://github.com/Colt/webpack-demo-app#readme\", \"devDependencies\": &#123; // --save-dev 指令裝的套件將會幫我們放到 package.json 的 devDependencies 中 \"webpack\": \"^4.35.0\", // Webpack 裝好了！ \"webpack-cli\": \"^3.3.4\" // Webpack 裝好了！ &#125;&#125; &quot;scripts&quot; 新增自訂指令 \"scripts\": &#123; \"start\": \"webpack\"&#125; 執行 Webpack npm start 直接在 Terminal 執行 npm start 會拋出一個錯誤 ERROR in Entry module not found: Error: Can't resolve './src' in 'your-directory/webpack-demo-app'。發現在 ./src 這個資料夾找不到 index.js，所以在 ./src 這個資料夾下建立 index.js 後再試一次 npm start 看看編譯的狀況。 顯示一個警告，設定檔中的模式參數 mode 未設定，預設值是 production，所以幫你在專案中，產生靜態資料夾 dist： WARNING in configurationThe 'mode' option has not been set, webpack will fallback to 'production' for this value. Set 'mode' option to 'development' or 'production' to enable defaults for each environment.You can also set it to 'none' to disable any default behavior. Learn more: https://webpack.js.org/configuration/mode/ （因為這時還沒有建立設定檔，主要是先試試 Webpack 的預設會如何編譯。） Imports, Exports, &amp; Webpack Modules 可以根據程式的相依函式來設定 ES6 的 import、export： // 將變數 inputsAreValid exportexport const inputsAreValid = (...input) =&gt; &#123; return input.every(num =&gt; typeof num === \"number\" &amp;&amp; !isNaN(num));&#125;; // 其他使用的檔案則可以 importimport &#123; inputsAreValid &#125; from \"./utils/inputs-are-valid\"; index.js 是 Webpack 的進入點，放在專案根目錄（root）。 原本的程式碼在寫完後，如果以功能區分會拆成眾多檔案，那麼在 HTML 引入時會因為順序不同而影響執行，所以要導入 Webpack 讓我們可以把心力放在寫程式上面。 將程式碼模組化之後，只要在程式碼中，確定你需要的變數或 function 有 export，並且在需要的地方 import，自此就可以不需擔心 .js 檔案在 HTML 中引入的順序囉！ 解決了以下問題： 若使用外部 Library，不容易辨識哪些程式碼相依於外部 Library 相依的程式如果順序錯誤就會造成程式執行異常 相依的程式若是引入卻未使用，瀏覽器還是得無意義地強制加載 設定 在專案根目錄建立 webpack.comfig.js。 // webpack.comfig.jsconst path = require(\"path\"); // 引入 path 來解決巢狀引入路徑問題module.exports = &#123; mode: \"development\", // 設定開發模式就不會 minify devtool: \"none\", // 編譯後的程式碼不會有 eval 這樣的用法 entry: \"./src/index.js\", output: &#123; filename: \"hello.js\", // 編譯後的檔名 path: path.resolve(__dirname, \"your-directory-name\") // 編譯後要放在哪個資料夾 &#125;&#125;; 把指令更改為：以後 npm start 要根據我的 Webpack 設定檔辦事囉！ // package.json&#123; \"scripts\": &#123; \"start\": \"webpack --config webpack.comfig.js\" &#125;&#125; Loaders: CSS SASS 什麼是 Loader？ 在使用 Webpack 時，我們可以引入 .js以外的其他類型檔案，而 Loader 是 Webpack 中強大的工具，用來幫我們預處理你引入的各種類型檔案。詳情請參考官方文件 - Loaders。 建立一個 .css 檔案 /* main.css */body &#123; background: #009688;&#125; 安裝 style-loader 與 css-loader npm install --save-dev style-loader css-loader 新增 css-loader 規則 // add it to webpack.config.jsmodule: &#123; rules: [ &#123; test: /\\.css$/, // 正則式，$ 用以表示以 .css 結尾的檔案，反斜線是跳脫字元 use: [\"style-loader\", \"css-loader\"] &#125; ];&#125; css-loader：先取得你的 CSS 樣式，把它變成 JavaScript。 style-loader：將轉譯的 JavaScript 變成真正的 CSS 樣式，透過 &lt;style&gt; tag 插入你的 DOM tree。 而 webpack 編譯時，從陣列的最後一個開始往前執行，了解流程之後，之後 Loader 的使用順序是有差異的喔！ 先寫 style-loader，再來才是 css-loader。 可以直接引入 CSS 囉！ // index.jsimport &#123; mainCSS &#125; from \"./main.css\"; 以下筆記待續。 Cache Busting and Plugins 切割開發版本與產品版本 Html-loader, File-loader 以及乾淨的 webpack 多個 Entrypoints 及 Vendor.js 提取 CSS，將 HTML/CSS/JS 最小化 主要 Reference 影片教學 FreeCodeCamp 教學 @youtube 時間軸大綱 ⌨️ (0:00:00) What Even Is Webpack?? ⌨️ (0:08:12) Installing and Running Webpack and Webpack-CLI ⌨️ (0:22:18) Imports, Exports, &amp; Webpack Modules ⌨️ (0:29:58) Configuring Webpack ⌨️ (0:38:57) Loaders, CSS, &amp; SASS ⌨️ (0:53:55) Cache Busting and Plugins ⌨️ (1:07:13) Splitting Dev &amp; Production ⌨️ (1:17:13) Html-loader, File-loader, &amp; Clean-webpack ⌨️ (1:28:17) Multiple Entrypoints &amp; Vendor.js ⌨️ (1:34:45) Extract CSS &amp; Minify HTML/CSS/JS 其他 Reference Ｗ ebpack 官網 Webpack Tutorial 繁體中文 Gitbook Webpack 教學 (一) ：什麼是 Webpack? 能吃嗎？ Better local require() paths for Node.js","link":"/what-is-webpack/"},{"title":"Bulma 介紹及用法，透過 cheatsheet 快速閱讀文件","text":"Bulma 講到 CSS Framework，應該無人不知 Bootstrap。最近在 State of CSS 2019 的問卷結果中看到全球 CSS 使用數據，包含知名度、感興趣程度及使用滿意度，Bootstrap 的滿意度極低，而 Bulma 在使用滿意度算表現得很好，高達 74%，居於第二名，滿意度的第一名是 Taiwlind。CP 值好高，所以想來試試看 Bulma！ 知名度：**50%**｜ (全部受測數 - 從沒聽過的人) / 全部受測數 感興趣：**41%**｜有興趣 / (有興趣 + 沒興趣) 滿意度：**74%**｜想再使用 / (想再使用 + 不想再使用) 本篇文章純粹紀錄如何使用，方便自己日後忘記可以快速上手，不會與其他 CSS Framework 進行比較唷。 Bulma 的 Responsive Web Design 跟 Bootstrap 4 一樣，也是利用 flexbox 來實現的，這篇記錄的 Bulma 版本是 0.7.5。 tl;dr 感想、使用心得 一開始光看文件不太好找到需要的元件，不過原始碼和成果的對照還算清楚，超輕量！使用下來，安排網頁架構時，元素不影響權重很棒，也能自定義自己的色系，一律採用一個 component 組合搭配 modifiers，整體使用上也還算直覺，所以上手得快。 安裝方法 依你的情境選擇你想怎麼引入，詳見 官方文件 或 GitHub。 CDN 到 cdnjs 這個 CDN 平台選擇版本，並引入至 HTML 中。 &lt;link rel=\"stylesheets\" src=\"https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.5/css/bulma.min.css\"/&gt; 本地引入 至 GitHub Repo 下載 CSS 檔案至本地的專案資料夾中，並引入至 HTML 中。src 中的./ 表相對路徑。 &lt;link rel=\"stylesheets\" src=\"./your-directory/bulma.min.css\" /&gt; NPM / Yarn npm install bulma-start 或是 yarn add bulma-start NPM package 有包含哪些項目及相依套件請參考：What’s included。 注意： 要使用 bulma 中有含 icon 的輪子，要記得引入 Font Awesome 5。 要宣告 HTML5 的檔案類型，&lt;!DOCTYPE html&gt;，以利正常顯示。 要宣告自適應的 viewport 宣告，以利正常顯示。 &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /&gt; 概覽 類別：只有 class，純粹架構 HTML 時不會影響樣式。 genertic.sass：定義頁面基本樣式。 使用 .content 類別作為文字內容的容器，就可以輕鬆的使用 modifiers，套用 tag 樣式。 &lt;p&gt; paragraphs &lt;ul&gt; &lt;ol&gt; &lt;dl&gt; lists &lt;h1&gt; to &lt;h6&gt; headings &lt;blockquote&gt; quotes &lt;em&gt; and &lt;strong&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt; &lt;td&gt; tables 模組化：有 39 個獨立的 sass 檔案，可單獨引入。 如果你想使用網格系統，只要引入： @import \"bulma/sass/utilities/_all.sass\"@import \"bulma/sass/grid/columns.sass\" &lt;div class=\"columns\"&gt; &lt;div class=\"column\"&gt;1&lt;/div&gt; &lt;div class=\"column\"&gt;2&lt;/div&gt; &lt;div class=\"column\"&gt;3&lt;/div&gt; &lt;div class=\"column\"&gt;4&lt;/div&gt; &lt;div class=\"column\"&gt;5&lt;/div&gt;&lt;/div&gt; 如果你想使用 buttons，只要引入，就可以使用這些 .button 及 modifers： .is-active .is-primary, .is-info, .is-success… .is-small, .is-medium, .is-large .is-outlined, .is-inverted, .is-link .is-loading, [disabled] @import \"bulma/sass/utilities/_all.sass\"@import \"bulma/sass/elements/button.sass\" &lt;button class=\"button\"&gt;Button&lt;/button&gt;&lt;button class=\"button is-primary\"&gt;Primary button&lt;/button&gt;&lt;button class=\"button is-large\"&gt;Large button&lt;/button&gt;&lt;button class=\"button is-loading\"&gt;Loading button&lt;/button&gt; 自適應：預設是「垂直」佈局。 行動裝置為優先、垂直式閱讀設計。可以在 .columns及 .level 加上 .is-mobile強制改成水平佈局。 顏色：10 種顏色及 8 個層級的陰影。 可以透過變數去自定義你的。設定：.is-$color，比如說 .is-primary 或 .is-dark。 functions：提供 3 個 functions 去動態定義「值」、「顏色」。 powerNumber($number, $exp)：計算相對暴露值，回傳數字。（目前尚不理解！） colorLuminance($color)：計算亮度該是 dark 還是 light，回傳介於 0 與 1 之間的值（light: &gt; 0.5, dark: &lt;= 0.5，十進位）。 findColorInvert($color)：根據顏色的明亮度去計算該是黑色rgba(#000, 0.7)還是白色#fff。確保按鈕上文字搭配背景顏色後的可讀性。 mixins：提供 arrow($color)、clearfix、loader、overflow-touch…等可使用，詳見文件。 我的 Cheatsheet 不是完整官方文件的 cheatSheet，由於一開始看 Bulma 不熟悉，所以串得不是很起來，透過整理 bulma 教學影片去熟悉 bulma 的架構與設計，這時搭配文件非常好上手了～ 文字內容 Context 標題 Heading：使用 .title。 使用 .title 搭配 modifiers。 &lt;h1 class=\"title is-1\"&gt;Hello Askie&lt;/h1&gt;&lt;h2 class=\"title is-2\"&gt;Hello Askie&lt;/h2&gt;&lt;h3 class=\"title is-3\"&gt;Hello Askie&lt;/h3&gt;&lt;h4 class=\"title is-4\"&gt;Hello Askie&lt;/h4&gt;&lt;h5 class=\"title is-5\"&gt;Hello Askie&lt;/h5&gt;&lt;h6 class=\"title is-6\"&gt;Hello Askie&lt;/h6&gt; 內容 Content：使用 .content。 使用 .content 搭配 modifiers。 &lt;p&gt; paragraphs &lt;ul&gt; &lt;ol&gt; &lt;dl&gt; lists &lt;h1&gt; to &lt;h6&gt; headings &lt;blockquote&gt; quotes &lt;em&gt; and &lt;strong&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt; &lt;td&gt; tables modifiers sizes：3 級。 &lt;p class=\"content is-small\"&gt;Hello Askie and Hello World!&lt;/p&gt;&lt;p class=\"content is-medium\"&gt;Hello Askie and Hello World!&lt;/p&gt;&lt;p class=\"content is-large\"&gt;Hello Askie and Hello World!&lt;/p&gt; 按鈕 Buttons colors：11 種顏色，可搭配 sizes 使用。 &lt;!-- buttons and colors --&gt;&lt;button class=\"button\"&gt;Button&lt;/button&gt;&lt;button class=\"button is-white\"&gt;Button&lt;/button&gt;&lt;button class=\"button is-light\"&gt;Button&lt;/button&gt;&lt;button class=\"button is-dark\"&gt;Button&lt;/button&gt;&lt;button class=\"button is-black\"&gt;Button&lt;/button&gt;&lt;button class=\"button is-link\"&gt;Button&lt;/button&gt;&lt;!-- links: like a button style --&gt;&lt;a href=\"\" class=\"button is-primary\"&gt;Primary&lt;/a&gt;&lt;a href=\"\" class=\"button is-info\"&gt;Info&lt;/a&gt;&lt;a href=\"\" class=\"button is-success\"&gt;Success&lt;/a&gt;&lt;a href=\"\" class=\"button is-warning\"&gt;Warning&lt;/a&gt;&lt;a href=\"\" class=\"button is-danger\"&gt;Danger&lt;/a&gt; .is-outlined外框按鈕 &lt;!-- outline --&gt;&lt;a href=\"\" class=\"button is-danger is-outlined\"&gt;Danger&lt;/a&gt; .is-inverted反相按鈕 &lt;!-- inverted --&gt;&lt;a href=\"\" class=\"button is-danger is-inverted\"&gt;Danger&lt;/a&gt; 按鈕狀態 &lt;a href=\"\" class=\"button is-hovered\"&gt;Hovered&lt;/a&gt;&lt;a href=\"\" class=\"button is-focused\"&gt;Focused&lt;/a&gt;&lt;a href=\"\" class=\"button is-active\"&gt;Active&lt;/a&gt;&lt;a href=\"\" class=\"button is-loading\"&gt;Loading&lt;/a&gt;&lt;a href=\"\" class=\"button\" disabled&gt;Disabled&lt;/a&gt; 區塊 Boxes! &lt;div class=\"box\"&gt; &lt;h1 class=\"title\"&gt;Hello world&lt;/h1&gt; &lt;p&gt;lorem ipsum&lt;/p&gt;&lt;/div&gt; 通知 Notifications &lt;div class=\"notification is-success\"&gt; &lt;button class=\"delete\"&gt;&lt;/button&gt; lorem ipsum&lt;/div&gt; 標籤 Tags &lt;span class=\"tag\"&gt;Hello&lt;/span&gt;&lt;span class=\"tag is-black\"&gt;black&lt;/span&gt;&lt;span class=\"tag is-danger is-medium\" &gt;Danger &lt;button class=\"delete\"&gt;&lt;/button&gt;&lt;/span&gt; 訊息 Messages &lt;article class=\"message is-primary\"&gt; &lt;header class=\"message-header\"&gt;&lt;p&gt;About Us&lt;/p&gt;&lt;/header&gt; &lt;div class=\"message-body\"&gt;Holly yes!!&lt;/div&gt;&lt;/article&gt; 導覽列 Navigations &lt;nav class=\"nav\"&gt; &lt;!-- 導覽列容器 --&gt; &lt;div class=\"nav-left\"&gt; &lt;!-- 對齊方式：置左 --&gt; &lt;a href=\"\" clas=\"nav-item\" &gt;&lt;!-- 元素 --&gt; &lt;h1 class=\"title is-4\"&gt;Askie Lin&lt;/h1&gt; &lt;!-- 標題 --&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=\"nav-right nav-menu\"&gt; &lt;!-- 對齊方式：置右，是一個選單 --&gt; &lt;a href=\"\" clas=\"nav-item\"&gt;A&lt;/a &gt;&lt;!-- 元素 --&gt; &lt;a href=\"\" clas=\"nav-item\"&gt;B&lt;/a &gt;&lt;!-- 元素 --&gt; &lt;a href=\"\" clas=\"nav-item\"&gt;C&lt;/a &gt;&lt;!-- 元素 --&gt; &lt;/div&gt;&lt;/nav&gt; Hero &lt;section class=\"hero is-warning\"&gt; &lt;!-- hero 容器 --&gt; &lt;div class=\"hero-body\"&gt; &lt;!-- hero 主體 --&gt; &lt;div class=\"container\"&gt; &lt;!-- 不一定需要，範例的情境適合用一個 container 包起來 --&gt; &lt;h1 class=\"title\"&gt;Hello World&lt;/h1&gt; &lt;h2 class=\"subtitle\"&gt;I am Askie Lin.&lt;/h2&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt; 卡片 Cards &lt;section class=\"card is-warning\"&gt; &lt;!-- card 容器 --&gt; &lt;div class=\"card-content\"&gt; &lt;!-- card 主體 --&gt; &lt;p class=\"title\"&gt;Hello world, Askie.&lt;/p&gt; &lt;/div&gt; &lt;footer class=\"card-footer\"&gt; &lt;!-- card 頁尾 --&gt; &lt;p class=\"card-footer-item\"&gt; &lt;!-- 頁尾元素 --&gt; &lt;span&gt;View on&lt;a href=\"\"&gt;Twitter&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; &lt;p class=\"card-footer-item\"&gt; &lt;!-- 頁尾元素 --&gt; &lt;span&gt;Share on&lt;a href=\"\"&gt;Facebook&lt;/a&gt;&lt;/span&gt; &lt;/p&gt; &lt;/footer&gt;&lt;/section&gt; 頁數 Pagination 容器使用 .pagination。 功能使用 .pagination-previous 上一頁 / .pagination-next 下一頁。 頁數主體使用 unordered list。 頁數元素使用 .pagination-link，modifiers 有無法點擊 disabled 及目前所在頁數 .is-current。 &lt;nav class=\"pagination\"&gt; &lt;!-- pagination 容器 --&gt; &lt;a href=\"\" class=\"pagination-previous\" disabled&gt;Previous&lt;/a &gt;&lt;!-- 上一頁 --&gt; &lt;a href=\"\" class=\"pagination-next\" disabled&gt;Next Page&lt;/a &gt;&lt;!-- 下一頁 --&gt; &lt;ul&gt; &lt;!-- pagination 主體 --&gt; &lt;li&gt;&lt;a href=\"\" class=\"pagination-link is-current\"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;!-- 目前在這一頁 --&gt; &lt;li&gt;&lt;a href=\"\" class=\"pagination-link\"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\" class=\"pagination-link\"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; Level：協助水平對齊，適合刻一些小巧的元件放在裡面 容器使用 .level。 方向使用 .level-left/ .level-right。 元素使用 .level-item。 &lt;section class=\"level\"&gt;&lt;!-- level 容器 --&gt; &lt;div class=\"level-left\"&gt;&lt;!-- 水平置左 --&gt; &lt;p class=\"level-item\"&gt;&lt;a&gt;&lt;strong&gt;All&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;&lt;!-- level 元素 --&gt; &lt;p class=\"level-item\"&gt;&lt;a&gt;Published&lt;/a&gt;&lt;/p&gt; &lt;p class=\"level-item\"&gt;&lt;a&gt;Draft&lt;/a&gt;&lt;/p&gt; &lt;p class=\"level-item\"&gt;&lt;a&gt;Deleted&lt;/a&gt;&lt;/p&gt; &lt;p class=\"level-item\"&gt;&lt;a class=\"button is-primary\"&gt;All&lt;/a&gt;&lt;/p&gt;&lt;!-- 按鈕形狀的元素 --&gt; &lt;/div&gt; &lt;div class=\"level-right\"&gt;&lt;!-- 水平置右 --&gt; &lt;p class=\"level-item\"&gt;&lt;!-- level 元素 --&gt; &lt;div class=\"field\"&gt;&lt;!-- 表單區域 --&gt; &lt;div class=\"control\"&gt; &lt;input type=\"text\" class=\"input\" placeholder=\"Search...\"/&gt; &lt;/div&gt; &lt;/div&gt; &lt;/p&gt; &lt;/div&gt;&lt;/section&gt; 表單 Forms 使用.field 作為每個元素的區隔。 Input &lt;form&gt; &lt;div class=\"field\"&gt; &lt;!-- 表單元件的容器 --&gt; &lt;label class=\"label\"&gt;Name&lt;/label &gt;&lt;!-- 表單標題 --&gt; &lt;input type=\"text\" class=\"input\" placeholder=\"Eneter Name\" /&gt;&lt;!-- 表單 text 元素 --&gt; &lt;/div&gt; &lt;div class=\"field\"&gt; &lt;!-- 表單元件的容器 --&gt; &lt;label class=\"label\"&gt;Name&lt;/label &gt;&lt;!-- 表單標題 --&gt; &lt;input type=\"text\" class=\"input is-success\" placeholder=\"Eneter Name\" /&gt;&lt;!-- 配合 modifier --&gt; &lt;/div&gt;&lt;/form&gt; select &lt;form&gt; &lt;div class=\"field\"&gt; &lt;!-- 表單元件的容器 --&gt; &lt;label class=\"label\"&gt;Select&lt;/label &gt;&lt;!-- 表單標題 --&gt; &lt;p class=\"control\"&gt; &lt;span class=\"select\"&gt; &lt;select&gt; &lt;option&gt;開始選吧！&lt;/option&gt; &lt;option&gt;簡單&lt;/option&gt; &lt;option&gt;中等&lt;/option&gt; &lt;option&gt;困難&lt;/option&gt; &lt;/select&gt; &lt;/span&gt; &lt;/p&gt; &lt;/div&gt;&lt;/form&gt; textarea &lt;form&gt; &lt;div class=\"field\"&gt; &lt;!-- 表單元件的容器 --&gt; &lt;label class=\"label\"&gt;Textarea&lt;/label &gt;&lt;!-- 表單標題 --&gt; &lt;p class=\"control\"&gt; &lt;!-- 利用 control 區分元素區塊 --&gt; &lt;textarea class=\"textarea\" placeholder=\"Type somthing...\"&gt;&lt;/textarea&gt; &lt;/p&gt; &lt;/div&gt;&lt;/form&gt; 使用 icons： &lt;form&gt; &lt;!-- example 1 --&gt; &lt;div class=\"field has-addons\"&gt; &lt;!-- 表單元件的容器 --&gt; &lt;p class=\"control\"&gt; &lt;!-- 利用 control 區分元素區塊 --&gt; &lt;input type=\"text\" class=\"input\" placeholder=\"Eneter Keywords...\" /&gt;&lt;!-- 表單 text 元素 --&gt; &lt;/p&gt; &lt;p class=\"control\"&gt; &lt;!-- 利用 control 區分元素區塊 --&gt; &lt;a href=\"\" class=\"button is-info\"&gt;搜尋&lt;/a&gt; &lt;/p&gt; &lt;/div&gt; &lt;!-- example 2 --&gt; &lt;div class=\"field has-addons\"&gt; &lt;!-- 表單元件的容器 --&gt; &lt;p class=\"control\"&gt; &lt;!-- 利用 control 區分元素區塊 --&gt; &lt;span class=\"select\"&gt; &lt;select&gt; &lt;option&gt;新台幣&lt;/option&gt; &lt;option&gt;美金&lt;/option&gt; &lt;option&gt;日圓&lt;/option&gt; &lt;/select&gt; &lt;/span&gt; &lt;/p&gt; &lt;p class=\"control\"&gt; &lt;!-- 利用 control 區分元素區塊 --&gt; &lt;input type=\"text\" class=\"input\" placeholder=\"填寫金額\" /&gt;&lt;!-- 表單 text 元素 --&gt; &lt;/p&gt; &lt;p class=\"control\"&gt; &lt;!-- 利用 control 區分元素區塊 --&gt; &lt;a href=\"\" class=\"button is-info\"&gt;送出&lt;/a&gt; &lt;/p&gt; &lt;/div&gt;&lt;/form&gt; 表格 Tables modifiers，可以交互使用 .table 容器 .is-striped：灰白相間的表格。 .is-bodered：邊框的表格。 .is-narrow：窄一點的表格。 tr .is-selected：選擇中的列。 &lt;table class=\"table \"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;姓氏&lt;/th&gt; &lt;th&gt;名字&lt;/th&gt; &lt;th&gt;星座&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;林&lt;/td&gt; &lt;td&gt;ＯＯ&lt;/td&gt; &lt;td&gt;牡羊座&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;王&lt;/td&gt; &lt;td&gt;ＸＸ&lt;/td&gt; &lt;td&gt;射手座&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 網格系統 Grid System 純粹的網格，不論裡面有「幾格」都會自動排好： &lt;div class=\"columns\"&gt; &lt;div class=\"column\"&gt;&lt;p class=\"notification\"&gt;First Column&lt;/p&gt;&lt;/div&gt; &lt;div class=\"column\"&gt;&lt;p class=\"notification\"&gt;Second Column&lt;/p&gt;&lt;/div&gt; &lt;div class=\"column\"&gt;&lt;p class=\"notification\"&gt;Third Column&lt;/p&gt;&lt;/div&gt;&lt;/div&gt; 十二網格系統，搭配 modifiers .is-$number： &lt;div class=\"columns\"&gt; &lt;div class=\"column is-2\"&gt;&lt;p class=\"notification\"&gt;2 Column&lt;/p&gt;&lt;/div&gt; &lt;div class=\"column is-8\"&gt;&lt;p class=\"notification\"&gt;8 Column&lt;/p&gt;&lt;/div&gt; &lt;div class=\"column is-2\"&gt;&lt;p class=\"notification\"&gt;2 Column&lt;/p&gt;&lt;/div&gt;&lt;/div&gt; 某一格佔據「四分之三」，剩下的自動排好： &lt;div class=\"columns\"&gt; &lt;div class=\"column is-three-quarters\"&gt; &lt;p class=\"notification\"&gt;四分之三&lt;/p&gt; &lt;/div&gt; &lt;div class=\"column\"&gt;&lt;p class=\"notification\"&gt;Auto&lt;/p&gt;&lt;/div&gt; &lt;div class=\"column\"&gt;&lt;p class=\"notification\"&gt;Auto&lt;/p&gt;&lt;/div&gt;&lt;/div&gt; 某一格佔據「三分之二」，剩下的自動排好： &lt;div class=\"columns\"&gt; &lt;div class=\"column is-two-thirds\"&gt;&lt;p class=\"notification\"&gt;三分之二&lt;/p&gt;&lt;/div&gt; &lt;div class=\"column\"&gt;&lt;p class=\"notification\"&gt;Auto&lt;/p&gt;&lt;/div&gt; &lt;div class=\"column\"&gt;&lt;p class=\"notification\"&gt;Auto&lt;/p&gt;&lt;/div&gt;&lt;/div&gt; 某一格佔據「一半」，剩下的自動排好： &lt;div class=\"columns\"&gt; &lt;div class=\"column is-half\"&gt;&lt;p class=\"notification\"&gt;50%&lt;/p&gt;&lt;/div&gt; &lt;div class=\"column\"&gt;&lt;p class=\"notification\"&gt;Auto&lt;/p&gt;&lt;/div&gt; &lt;div class=\"column\"&gt;&lt;p class=\"notification\"&gt;Auto&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;","link":"/intro-of-bulma-css-framework/"},{"title":"CSS Modules 在 Vue 的用法？和 CSS scoped 分別的優勢？","text":"Demo(本頁開啟) | 我的設計稿 撰寫 CSS 的過程中，都會搭配 SASS 預處理器，之前一直有聽過 CSS IN JS，不知該如何寫起？剛好今年六角學院的前端精神時光屋切了第一週的版（蕃茄鐘），想說用 Vue 來練習 CSS Modules，其實是看到 Vue Loader 官方文件的介紹，動手做做看，再 google 大大們的文章吸收一下日月精華，整理在此。 CSS IN JS（JavaScript） 大家都知道，其實 CSS 一直以來都不算是個程式語言，只能用來拿來描述網頁的長相，為了讓 CSS 也可以透過簡單的程式方法來解決一些維護、跨瀏覽器前綴及作用域的問題，出現了 LESS、SASS、Stylus、PostCSS 再到最近的 CSS IN JS。CSS IN JS 是 CSS 近年來最大的發展之一，倚靠 JavaScript 強大的力量，讓開發者終於可以透過 JavaScript 來管理 CSS。 以下是今年 CSS IN JS 的排名： 參考來源：State of CSS 2019 CSS Modules 優勢？解決什麼事？ CSS Modules 顧名思義就是希望能真正將 CSS 模組化，其非常單純，透過 webpack 幫我們自動化，動態產生 class 名稱，解決以下問題，又可以和其他預處理器一同使用，如 SASS！ 解決 BEM 要解決的問題： 降低 CSS 權重（優先級）也就是說，降低了區塊與區塊之間的相依性 新增了後綴，解決了「Global 作用域」的問題 但是繼續保持模組化、可重複使用的優點！ 如 Vue 中，CSS scoped 已經可以隔開作用域，此時就會有複用 我使用 BEM 已經很習慣了，可是人性就是懶惰，如果不是自己懶，就是隊友懶，以手動的做法來說，怎麼樣都還是有隱性問題會藏在專案中，不如交給自動化。 如何使用 CSS Modules？（Vue and React） Vue 我目前 Vue Cli 使用的版本是 3.9.2，已經有整合 CSS Modules 到開發環境中，不需再另外設定。他會在 CSS modules 啟用後，在 computed 產生一個屬性。 查看版本：vue --version 與 CSS scoped 最大不同，是 CSS scoped 雖然也會在 class 名稱加上一個後綴屬性，將元件內 CSS 指定其作用域，可是他並不能完全避免衝突。 vue 單檔內的使用方法： 將 &lt;style&gt; 加上 module 屬性： 是單數喔！注意不是 modules，因為我就加錯過，新手會犯的錯，找半天。 &lt;style module&gt; .title &#123; font-size: 2rem; &#125;&lt;/style&gt; 在樣板 &lt;template&gt;裡引用，需要 v-bind 上 class： &lt;!-- 單純的 class 名稱 --&gt;&lt;template&gt; &lt;div id=\"app\"&gt; &lt;h1 :class=\"$style.title\"&gt;Hello world, askie.&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt; &lt;!-- 有連字號的 class 名稱 --&gt;&lt;template&gt; &lt;div id=\"app\"&gt; &lt;h1 :class=\"$style['my-title']\"&gt;Hello world, askie.&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt; 搭配 Vue Class Binding：官方範例 &lt;p :class=\" &#123; [$style.red]: isRed &#125;\"&gt; 是紅色的嗎？你決定！&lt;/p&gt;&lt;p :class=\" [$style.red, $style.bold]\"&gt; 我是紅色的字，並且是粗體。&lt;/p&gt; keyframes 動畫名稱必須先寫： animation: pop 0.5s; // =&gt; animation: p_nfriono0d3eG_08_1 1s; 如果，你把動畫名稱寫在「後面」就會解析失敗： animation: 0.5s pop; // =&gt; animation: 1s :local(pop); 獨立檔案作法：將獨立的 CSS 檔案作為 CSS Modules 載入 import styles from './styles.module.scss'; 其他設定 可以參考Vue Loader 官方文件、Vue-js-與-CSS-Modules - Kuro 大大，幫助了我快速理解 CSS Modules 起源、目的、解決了什麼事，以及如何使用。謝謝～ React: 本身沒有寫 React，謹將範例列在此，以供查閱（範例來源） 區域選擇器：一個一個單獨選你的 class import styles from './ScopedSelectors.css';import React, &#123; Component &#125; from 'react';export default class ScopedSelectors extends Component &#123; render() &#123; return ( &lt;div className=&#123;styles.root&#125;&gt; &lt;p className=&#123;styles.text&#125;&gt;Scoped Selectors&lt;/p&gt; &lt;/div&gt; ); &#125;&#125; // ScopedSelectors.css.root &#123; border-width: 2px; border-style: solid; border-color: #777; padding: 0 20px; margin: 0 6px; max-width: 400px;&#125;.text &#123; color: #777; font-size: 24px; font-family: helvetica, arial, sans-serif; font-weight: 600;&#125; 全域選擇器 import styles from './GlobalSelectors.css';import React, &#123; Component &#125; from 'react';export default class GlobalSelectors extends Component &#123; render() &#123; return ( &lt;div className=&#123;styles.root&#125;&gt; &lt;p className='text'&gt;Global Selectors&lt;/p&gt; &lt;/div&gt; ); &#125;&#125; .root &#123; border-width: 2px; border-style: solid; border-color: brown; padding: 0 20px; margin: 0 6px; max-width: 400px;&#125;.root :global .text &#123; color: brown; font-size: 24px; font-family: helvetica, arial, sans-serif; font-weight: 600;&#125; 組成 Compose，概念近於 SASS extend 使用 composes 這個屬性，去引入你的共用的 CSS 模組。 // 動畫範例import styles from './ScopedAnimations.css';import React, &#123; Component &#125; from 'react';export default class ScopedAnimations extends Component &#123; render() &#123; return ( &lt;div className=&#123;styles.root&#125;&gt; &lt;div className=&#123;styles.ball&#125; /&gt; &lt;/div&gt; ); &#125;&#125; // ScopedAnimations.css.root &#123; padding: 20px 10px;&#125;.ball &#123; composes: bounce from 'shared/styles/animations.css'; width: 40px; height: 40px; border-radius: 20px; background: rebeccapurple;&#125; // shared/styles/animations.css@keyframes bounce &#123; 33% &#123; transform: translateY(-20px); &#125; 66% &#123; transform: translateY(0px); &#125;&#125;.bounce &#123; animation: bounce 1s infinite ease-in-out;&#125;","link":"/vue-difference-between-css-modules-and-css-scoped/"},{"title":"符合無障礙規範一定要了解！把「通用設計」的思考融入骨子裡","text":"現在因為要製作政府的專案，需要符合國家通訊傳播委員會的無障礙規範，google 通用設計的概念，意圖去了解無障礙設計與通用設計的差異。後來看到大愛電視台，唐峰正老師的分享「通用設計」，發現：其實我們做的每一件事情都能增添溫度 - 同理心。 大家都知道，一個好的網站需要包含很多要素。其中有一個很大的 topic，「Accessible Web / Accessibility」，卻經常淪為建構網站時，有時間才去優化的事情，是一個 option 而不是 main feature。 Accessibility \\-​ˌse-​sə-​ˈbi-​lə-​tē \\ 中文常翻譯為「網頁親和力」。線上字典聽發音。 學習到的重點 無障礙設計 專爲身障者考量的設計，讓他們使用設備或空間時不會受到阻礙。 通用設計是「利他精神」。 目的是：不凸顯使用者差異、不增加其心理負擔。通用設計所考量的對象則不侷限於身障者，還有其他的使用族群，也許是身體機能退化的高齡者，也可能是使用習慣和多數人不同的左撇子，或是身材嬌小的矮個子、大腹便便的孕婦、推著娃娃車的人等等。 無障礙設計與通用設計最大的區別（2019-07-28 補充） Universal design is different from accessible design in that there are not two different solutions - 來源 「無障礙設計 Accessible Design」需要考量不同對象而有需要額外製作第二套解決方案，而「通用設計 Universal Design」沒有兩種不同的方案，而是一種方式就能滿足所有人的需求。 如果一開始就針對全民設計，將會： 成本降低 使用者增加 七大原則 公平 簡單易用 彈性 空間 容錯 省力 直覺 人生大風車：人生有大多數充斥的需要被設計的事物。 人生不同階段 幼兒 學生 社會人士 老年 不同的椅子 娃娃車 學生椅 電腦椅 輪椅 「同理心」並非「同情心」，而是有溫度的思考。也就是以下： 只要有表達出來，我都願意幫你 在被幫助的時候，也不要因為被幫助，而喪失自己原本的能力 把彼此的問題，都加進來一起思考 全人關懷環境，去思考： 誰在用？ 誰要用？ 誰想用？ 專心做一件事，過程中也許會被質疑、不認同你，但當它出現意義、出現價值時，你才可以告訴你自己，你是活著的。＿唐峰正顧問 上面這句話，不小心融入我的血裡、我的骨子裡了。 稍稍了解之後，我的想法是，如果網站在建構初期時，設計者與開發者有著全面族群的思考方向，自然就容易把事情做好、把格局做大。 補充無障礙相關資訊！（方便別人、方便自己） 線上資源 如果你也跟我一樣：目前正在了解無障礙的規範該如何去實踐，不外乎要知道載體、開發者工具的使用、語意標籤及相關的 aria-label 內容設定。 可以參考的線上資源有：Google Web Fundamental 及 Google 提供的免費課程、w3org: WAI-ARIA Overview、w3org: Accessibility Fundamentals、web.dev: Accessible to all 有規範 / 建議 / 學習資源。 之後完成專案後再來說一下心得與工具。 我這個專案將會使用 Vue 開發，其實不論你用什麼框架，真正的關鍵字，叫做「A11Y」，是 eslint 的套件，當你的結構未符合 Accessibility 時就會有錯誤提示，感謝 Huli 胡立大大 的補充！^^ Vue 可以使用：eslint-plugin-vue-a11y，more… React 可以使用：eslint-plugin-jsx-a11y Checklist for 網站無障礙規範 2.0 版 A 級 如果你也跟我一樣：需要符合政府的規範，也就是國家通訊傳播委員會的無障礙檢測，總共有三個等級（A, AA, AAA），我目前只需要通過 A 級，但因為官方的規範，結構、配色實在太難閱讀… 為了不想瞎掉，所以我手動整理了一個共筆清單，方便大家複製一份自己用。符合規範就自己打勾，也方便做 spec 驗收時確認，總之有一個 TOC 及資訊層級整理，總是比官方的版本閱讀性提高太多，較容易查找（OS: 明明就是官方的無障礙規範，排版排得連一般人都難以閱讀是怎樣 = =）。 我整理的共筆連結在此，歡迎拿去使用，官方範例也正在整理中 Issues 國家通訊委員會有提供檢測工具 Freego，我的電腦是 MacBook Pro，下載 Linux 版本卻不能使用，命令列似乎說有缺少的 java 套件…。 Reference 通用設計與無障礙設計的差異 Universal Design for Public Services 公共服務如何導入通用設計（余虹儀） 通用設計大學問 - 唐峰正顧問（萬分感謝！您真偉大）","link":"/accessible-design-and-universal-design-principles-for-all/"},{"title":"以 Vue 為例，如何在 VSCODE 自訂程式碼片段 Code Snippets？","text":"好，我習慣用的編輯器是 VSCODE，雖然有安裝一些 Snippets 擴充套件，讓我敲程式碼時比較不會因為打錯浪費時間 debug。但，真正開發時，創建結構時常常都要建立新檔案去切分 component，打幾乎同樣的程式碼有點煩，所以～找了一下該怎麼來設定自己要的程式碼片段。希望有幫助到你：） 一、設定 Setting.json 1-1. command + , 1-2. 右上角 {}，打開自定檔 1-3. 新增以下語法： // 啟用自訂程式碼樣版\"editor.tabCompletion\": \"on\",// 如果你跟我一樣，有裝其他的 Snippet，可以將編輯器的權重提高\"editor.snippetSuggestions\": \"top\", 二、在 VSCODE 新增自己的片段 2-1. shift + command + p 2-2. 輸入 &quot;User Snippets&quot;，選擇 Preferences:Configure User Snippets 2-3. 選擇語言，可以是 Global，因以 Vue 為例，我選擇 Vue。 有些參數說明，接下來，可以自己去瞭解參數或是使用 Snippets 設定產生工具！ VSCODE 官方說明 三、利用 snippet generator 創造自己的設定檔，感謝大大，快去追蹤他 XD snippet generator 產生器支援 VSCODE、SUBLIME、ATOM 唷，選擇自己的編輯器來設定吧。 prefix 就是你到時要生成自訂程式碼要輸入的。 &#123; // 第一次建立的朋友 // 記得產生器產生的設定檔需要放在一個『物件』裡 // 之後可以往下繼續新增你其他的 Snippets // 將自訂的程式碼設定檔貼在這裡&#125; 像這樣： &#123; \"Askie 自訂的 Vue 樣板\": &#123; \"prefix\": \"vuetem\", \"body\": [ \"&lt;template&gt;\", \" &lt;section&gt;Hello&lt;/section&gt;\", \"&lt;/template&gt;\", \"\", \"&lt;script&gt;\", \"export default &#123;\", \" name: 'Hello',\", \" data() &#123;\", \" return &#123;&#125;;\", \" &#125;,\", \" computed: &#123;&#125;,\", \" created() &#123;&#125;,\", \" mounted() &#123;&#125;,\", \" methods: &#123;&#125;,\", \" components: &#123;&#125;,\", \"&#125;;\", \"&lt;/script&gt;\", \"\", \"&lt;style lang=\\\"scss\\\" scoped&gt;\", \"&lt;/style&gt;\", \"\" ], \"description\": \"Askie 自訂的 Vue 樣板\" &#125;&#125; Easy？ 不過我有踩一下雷，就是第一步驟的設定檔，以及最後要將設定內容全放在一個物件中，怕忘了，也感覺新手第一次建立時會遇到問題，所以簡單做個紀錄。","link":"/vscode-custom-user-code-snippets-steps/"},{"title":"輕鬆地提交 Hexo 部落格的 Sitemap.xml 到 Google Search Console","text":"查看使用者搜尋什麼關鍵字 想提升 SEO ，所以之前就有把我的部落格網址提交到 Google Search Console，在後台能了解： 成效報表：網頁搜尋總點擊次數 使用者點擊錯誤的網址數量 使用者會搜尋什麼關鍵字而到你的部落格 使用者是從哪些國家搜尋 行動裝置可用性…等等 其中，蠻喜歡這幾個功能 「索引 &gt; 涵蓋範圍 &gt; 排除』：能去看哪些是被檢索後但失效的。 「連結」：查看外部連結，哪些最熱門，來你的部落格的人又是點擊了哪些外部連結。 產生 Sitemap.xml 在 Hexo 這樣的靜態網頁產生器，沒想到提交 Sitemap 這麼地容易，簡單做個紀錄。有一個 Plugin 叫做 hexo-generator-sitemap，可以幫助你產生 Sitemap.xml，就可以拿這份檔案去提交了唷！來看以下簡單三個步驟。 安裝 Install Terminal 在部落格路徑下，輸入以下指令 npm install hexo-generator-sitemap --save 設定 Config 打開你的部落格資料夾，打開根目錄的 _config.yml，在最後面貼上： # 注意：yml 非常在意縮排。sitemap: path: sitemap.xml template: ./sitemap_template.xml # 這行非必填，除非你想設定自訂的樣板 重新編譯一次，發布新內容： hexo g -d 檢查看看有沒有順利產生 Sitemap.xml？ https://askiebaby.github.io/sitemap.xml =&gt; 我的 提交至 Google Search Console 打開 Google Search Console 進入「索引 &gt; Sitemap」 「新增 Sitemap」：sitemap.xml 如果成功，就可以在頁面下方的列表看見紀錄與狀態了。 結論 Hexo 利用工具就能簡單產出「網站地圖」，真方便！！","link":"/upload-sitemap-google-search-console-seo-hexo-blog/"},{"title":"無障礙網站又稱為可訪問的網站，難道還有不可訪問的網站嗎？ What is an accessibe website exactly？","text":"只要花 60 秒瞭解「無障礙網站」概念 Your Website + Accessibility = BFF —— Jenn Lukas 前言 「網站」是一種資訊傳播的方式，我們製作網站最普遍的目的是為了將「資訊」傳播出去。比如說現今大多數公司會建置自己的官方網站，去傳達公司理念、服務項目、聯絡方式…等等，這些都在資訊的涵蓋範圍。 那你有聽過無障礙網站嗎？ 無障礙網站又稱為可訪問的網站，難道還有不可訪問的網站嗎？ 無障礙網站 無障礙網站又稱為 Web Accessibility 常以關鍵字 a11y 來代表無障礙技術，它是 Accessibility 的縮寫，代表網頁可訪問性，許多其他繁中翻譯會譯為可親性、可及性。這系列文章將以「可訪問性」代表 Accessibility、「無障礙」作為 Web Accessibility 的代稱。 縮寫方式 = A(ccessibilit)y = 以 A 為開頭，以 Y 結尾， A 與 Y 之間總共有 11 個字元！ 發音 可以唸作 A-one-one-Y 或是 A-eleven-Y，在業界也有人會唸作 ally 或是 alley 的發音。 其餘還有很多同樣形式的縮寫：如 g11n（globalization）、i18n（Internationalization）L10n（Localization）、p13n（personalization）、k8s（Kubernetes）等。 用愛開發，實踐「無障礙」 無論使用者是否有任何機能的低下、無論使用者使用何種方式與何種裝置瀏覽，無障礙的實踐將確保網站的內容以較多元、彈性的方式呈現，能夠提供給「所有人」瀏覽，有助於資訊能更廣泛地傳遞到更多人手中，拓展對不同能力的人的適應性。 重要性，你怎麼看？ 不可訪問的網站其實真的很多。 訪問性通常不是我們在設計、建置網站時的第一件事情，在某些問題出現以前，我們通常不會考量到隱形的需求。舉例一個情境：當我們處於產品開發週期的測試階段，某位使用者無法閱讀螢幕的文字，去瞭解才發現世界上男性中有 8% 的色盲。（從 WHO 了解視力障礙數據） 有些國家法律規定政府、教育機構、企業網站要符合無障礙的規範，以保障人權，訪問性的問題會在產品生命週期中蔓延，也會引發訴訟的問題。而且無障礙問題通常會出現在產品進入後期或是完成後，這時要從零導入「無障礙」實踐恐怕需要負擔更高額的成本。 再繼續往下之前，讓我們先來想想「障礙」的定義到底是什麼。 來思考「障礙」的定義 一個人有多種不同機能障礙的可能，「障礙（Disabled）」是一種相對的且會變動的狀態，也是一個事實的描述，是你的能力在所處「環境」下是否有辦法互動發揮作用而定。 在中文翻譯上，「無障礙」這個詞彙挺容易讓人直接聯想成：「喔！我們要做無障礙網站，那就是為了身心障礙人士瀏覽專用而設計嗎？」 無障礙網頁設計所設定的受惠者是「所有人」，與通用設計的理念相符，剛好其中有些特別的使用族群需要使用科技輔助工具（AT，全名為 Assistive Technology 如 NVDA、JAWS）、輔助功能（如 iOS 的 VoiceOver、Android 的 TalkBack）來瀏覽網頁，能力一般的人有時也有想要縮放網頁內容的需求，因此網頁在設計及開發時，設計上再細心一點，實作上注意細節就能增加網站的無障礙。讓我們用同理心、包容心和愛，盡可能達到「讓所有人瀏覽網站時都能享有獲得相同的資訊的權利」這個目標。 以人類的機能來區分障礙類型 物理，肢體上的障礙 開發基本原則：大多數的肢體障礙者都可以透過鍵盤瀏覽網站，所以開發時專注鍵盤的可訪問性。 創傷： 肢體損壞 脊髓損傷 疾病與先天性疾病： 腦癱 關節炎 帕金森氏症 認知，學習和神經系統的障礙 記憶力不佳 解決問題的能力 注意力不集中：自閉症、過動症（ADHD） 閱讀與言語理解困難 癲癇 動暈症（如暈車、暈船） 聽覺 開發基本原則：影片提供字幕或是手語翻譯、專注於螢幕閱讀器的可訪問性。 輕度：無法聽到 30 分貝以下的聲音。 中度：無法聽到 50 分貝以下的聲音。 重度：無法聽到 80 分貝以下的聲音。主要透過手語溝通。 嚴重：無法聽到 95 分貝以下的聲音。主要透過手語溝通。 視覺 開發基本原則：提升顏色對比度、填寫替代文字、減少顏文字的使用、確保超連結文字的提示性、超連結的路徑不要寫無意義的 JavaScript（ href=&quot;javascript: void;&quot; ）、勿僅靠顏色作為傳達重要訊息的唯一方式、資訊結構順序設計、文字不要壓在圖上…等。 色盲 色弱 失明 近視 青光眼 白化症 年邁的老人 還有一些是屬於暫時性或環境的障礙，比如網路速度不佳的問題、我們因為車禍導致手臂受傷而暫時無法使用滑鼠。 現實生活有哪些透過輔助技術消彌障礙的情境？ 近視配戴眼鏡或隱形眼鏡 長者配戴老花眼鏡 地面止滑設計防止行人跌倒 編輯器使用程式碼自動完成工具 … 多到不勝枚舉，因為習慣有輔助科技及輔助技術的協助，讓我們忽略自己的生活情境，也常需要透過外力協助去解決我們的問題。 體驗一下！讓開發者也有「色盲」 這邊舉一個小例子，讓各位感受一下色盲在觀看網頁時的感覺： import React from 'react'; import MenuItem from '../shared/menu'; import ItemMenu from '../shared/menu'; const App = () =&gt; ( &lt;&gt; &lt;MenuItem title=&quot;Home&quot; /&gt; &lt;MenuItem title=&quot;About&quot; /&gt; &lt;ItemMenu title=&quot;FAQ&quot; /&gt; &lt;MenuItem title=&quot;Gallery&quot; /&gt; &lt;ItemMenu title=&quot;Signup&quot; /&gt; &lt;MenuItem title=&quot;Contact Us&quot; /&gt; &lt;/&gt; ); export default App; 色盲的人永遠也不知道正常的人眼中看到的世界，就像正常人也永遠無法看到色盲人眼中的世界。若把「色盲瀏覽網頁」以「開發者觀看程式碼」來比喻的話就長上面這個樣子，原來是這麼難以閱讀。 開發無障礙網頁的好處 很多企業都開始重視起無障礙網站，因為實踐無障礙網站的過程，還可以達成以下優點 提高 SEO 搜尋引擎排名（看看這篇的內容） 吸引更廣泛的受眾、拓展市場機會 展示社會責任 提高易用性（Usability） 編寫更清晰的程式碼 降低產品成本：避免日後產品迭代時才需要從零導入無障礙的窘境 協助網路速度慢的使用者訪問 看完文章後，對於無障礙網站的觀念是不是有更多的認識跟釐清了呢？ 就跟著接下來的篇幅一起實踐可訪問的網站吧！ Reference Cognitve - WebAIM Visual - WebAIM Auditory - WebAIM Assistive - WebAIM Seizure - WebAIM React Rally 2019 @YouTube What is Web Accessibility in 60 seconds! - Google Women Techmaker Blindness and vision impairment - WTO 設計師 YR Cheng 聊聊 Accessibility Wikipedia - Accessibility Myth: Accessibility is ‘blind people’ - The A11Y Project","link":"/what-is-an-accessibe-website-exactly/"},{"title":"從零開始設定自己的開發環境、軟體推薦（MacOS）","text":"最近到了新的工作環境，公司配了一台新電腦，要從零來設置自己習慣的開發環境，所以除了安裝開發上很順手的工具以外，也額外想推薦大家來安裝能夠增加效率或是提升開發速度的軟體。這篇文章不會各別介紹每個工具詳細設定的流程，我選擇紀錄每個推薦的工具能夠為我解決什麼問題，等於是為了以後買新電腦又要重設開發環境做準備（？） 1. HomeBrew HomeBrew 官網 安裝各式套件的管道。 安裝指令 $ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 安裝後，確認版本 $ brew --version 2. GIT GIT 官網 版本控制管理系統，應該沒有開發者不知道，教學可以看高見龍老師的為你自己學 GIT。 剛開始使用 GIT 的初始化 檢視目前電腦中 GIT 全域設定的使用者是誰。可以看這一篇文章。 $ git config --listuser.name=Eddie Kaouser.email=eddie@5xruby.tw 都還沒設定過的話，來設定一下： $ git config --global user.name \"Askie Lin\"$ git config --global user.email \"askie_lin@xxxxxx.com\" 每個專案使用不同作者 在自己的專案中，透過 --local 參數來達成： $ git config --local user.name Kai$ git config --local user.email \"Kai@xxxxxx.com\" 做好修改的檔案會在這底下：~/.gitconfig 加上 log 高亮語法及 alias 增進你的速度，我的 ~/.gitconfig： [user] name = Askie Lin email = askie_lin@xxxxxx.com[alias] co = checkout br = branch cm = commit ca = commit --amend cane = commit --amend --no-edit st = status rb = rebase lg = log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit --branches 但其實如果說 alias 增進速度這一塊，我沒有使用很多 alias 的設定，只單純設定使用頻率頻繁的。 3. NVM NVM 官方文件 使用安裝 node，可以根據環境切換版本，也可以參考 node 官網對於 NVM 的使用說明：Installing Node.js via package manager 及這篇 Mac OSX 新手入門。 4. 安裝 iTerm 2 + Zsh iTerm 2 官網 讓 Terminal 可以自訂顯示的資訊及 UI，如顯示所在路徑、GIT 分支及狀態其實不只是好看，能夠增加工作效率。 關於 Zsh 一定要使用的設定 安裝 Auto suggestions (for Oh My Zsh) 能夠讓我們在 Terminal 輸入指令時，自動提示輸入過的指令，激推！ 簡述一下流程，流程取自於 PJCHENDer 的文章：為 MAC 的 Terminal 上色 - 透過 iTerm 2 和 Oh My Zsh 高亮你的終端機 在終端機輸入： $ git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions 打開 ZSH 設定檔： $ open ~/.zshrc 找到 plugins = “” 的地方，在 plugins 的欄位中加入”zsh-autosuggestion”後存檔： 原本 $ plugins=(git) 改成 $ plugins=(git zsh-autosuggestions) 5. 安裝 Visual Studio Code VS Code 官網 很棒的免費的編輯器，有中文化，擴充套件也很齊全。 推薦安裝 VS Code： SettingSync 有效備份每次的設定，在需要重新設定環境時，無痛接軌！ Terminal 使用 code 指令打開專案 想在 Terminal 想直接使用 VS Code 開啟專案嗎？ $ code . # 當前目錄路徑$ code /anyDirectory/you/want # 資料夾路徑 如果遇見以下錯誤訊息該怎辦？ zsh: command not found: code 查看 StackOverflow - “code .” Not working in Command Line for Visual Studio Code on OSX/Mac 這篇說明唷！ 6. 建立 SSH Key 教學激推 讓你從 GitHub 或 GitLab 拉原始碼回來時可以透過 SSH Key 的方式，安全、方便、快速的 clone。使用 HTTPS 的方式則是每次都會詢問帳號、密碼，非常繁瑣。 7. Postman POSTMAN 官網 打 API 的好幫手。 8. Magnet（付費） Magnet 官網 App Store 下載 Window Manager，讓 MAC 使用者用快速鍵就能輕鬆分配應用程式該放在螢幕的哪個位置。Perfect！ 記錄完了，收工！","link":"/how-to-setup-develop-environment/"},{"title":"初心者透過官方文件學習 React 十大概念（上）","text":"記錄著關於初學 REACT 時，官方文件提及的主要概念，基本上都是文件上的內容，希望用自己是初心者的方式整理關於 JSX、生命週期、事件處理器、官方文件的觀念，可以更記得住。 1. Hello World 應用程式基本組成：元素與組件。 ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('root')); 往下瞭解其他概念之前，可以先閱讀「重新介紹 JavaScipt」，如果好幾年沒碰 JavaScript 的話，看一下「三個心法」。 重新介紹 JavaScript：複習 JS 的主要核心概念，推薦閱讀！ 三個心法 以 let與 const定義變數，暫時當作與 var一樣意思的關鍵字。 使用 class關鍵字來定義 JavaScript class，有兩件事要知道： class中的方法定義不像 object一樣需要使用逗號做為區隔。 JavaScript的 this和其他語言的 this不同，this的值將取決於它如何被呼叫。 使用 ⇒定義 arrow functions，又稱為「箭號函式」，箭號函式沒有自己 this的值，可以保存外層方法中定義的 this的值。 2. JSX JSX 是 JavaScript 語法的擴充，看起來很像樣板語言，不一樣的是，JSX 裡頭可使用 JavaScript 全部的功能。 const element = &lt;h1&gt;你好，世界！&lt;/h1&gt;; UI、狀態與邏輯 在前端中，狀態邏輯與使用者介面本就是密不可分的，與其將之拆開到各個檔案中存放，不如關注在：以組件方式拆分，其中封裝好 UI 與邏輯，而組間之間彼此獨立，互不相依。 為什麼使用 JSX React 中，沒有要求非得使用 JSX，但它整合 UI 與邏輯，是很好的視覺輔助。 介紹 JSX 中可以使用表達式。 可以放入子節點（Children）。 跟 XML 一樣，如果一個標籤是空白的，你可以用 /&gt;立刻關閉這個標籤。 防止 XSS （跨網站指令碼）注入攻擊： React DOM預設先將所有嵌入在 JSX 中的變數，escape 並轉為字串後，才會 render。 透過 Babel 編譯成物件，呼叫 React.createElement()，以「tagName(String), attributes(Object), content(String)」作為參數，回傳 React Element。 建立 JSX const element = ( &lt;h1 className=\"greeting\"&gt; Hello, World! &lt;/h1&gt;); Babel 編譯，呼叫 React.createElement(tagName, attrs, content) const element = React.createElement( 'h1', &#123;className: 'greeting'&#125;, 'Hello, World!'); 回傳 React Element，React 讀這些物件紀錄的描述，來 Render DOM。 // 注意：這是簡化過的結構const element = &#123; type: 'h1', props: &#123; className: 'greeting', children: 'Hello, world!' &#125;&#125;; 在 JSX 類型中使用點記法 方便模組化 import React from 'react';const MyComponents = &#123; DatePicker: function DatePicker(props) &#123; return &lt;div&gt;Imagine a &#123;props.color&#125; datepicker here.&lt;/div&gt;; &#125; &#125;function BlueDatePicker() &#123; return &lt;MyComponents.DatePicker color=\"blue\" /&gt;; &#125; 3. Rendering Element 建立 React 應用程式最小的單位是 element。 React Element 是一個單純的 Object，它不是 DOM Element。 React Element 很容易被建立。 React DOM：負責更新 DOM，以符合 React Element。 Element ≠ Component 更精確的說，Element 是由 Components 組成。 Render Element 到 DOM 內 root DOM node：所有在內的 element 都會透過 React DOM 做管理。一個應用程式通常會有一個 root DOM node，也能根據需求獨立建立多個 root DOM node。 &lt;!-- index.html --&gt; &lt;div id=\"root\"&gt;&lt;/div&gt;const element = &lt;h1&gt;Hello, World&lt;/h1&gt;;ReactDOM.render(element, document.getElementById('root')); 更新被 Render 的 Element React Element 是 immutable 的，類比一下：電影中的一個幀，代表特定時間點的 UI。 在實踐中，大部分 React 應用程式只呼叫 ReactDOM.render() 一次。 React 只更新必要的 Element React DOM 會將「react element 與其 children」與先前狀態做比較，只更新必要的 DOM。 思考 UI 在任何時候應該如何呈現，而不是隨著時間的推移去消除錯誤。 4. Component 與 Props 組件是將 UI 拆分成獨立，可重複使用的程式碼，並專注各別程式碼的思考。 定義：像是 JavaScript 的 function，接收任意參數，又稱為 props，將回傳描述畫面的 React Element。 Function Component 與 Class Component 定義組件最簡單的方式：寫個 function，符合上述組件的定義： function component function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;[props.name](http://props.name/)&#125;&lt;/h1&gt;;&#125; class component class Welcome extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello, &#123; this.props.name &#125;&lt;/h1&gt;; &#125;&#125; 組件需要在作用域中被使用。自定義組件名稱，首字英文大寫。 import React from 'react';import CustomButton from './CustomButton';function WarningButton() &#123; // return React.createElement(CustomButton, &#123;color: 'red'&#125;, null); return &lt;CustomButton color=\"red\" /&gt;;&#125; 不要害怕抽離組件，因為已經會抽離組件，所以筆記中不贅述。 Props 是唯讀的 不管使用 function 或是 class 來宣告組件，絕對不能修改自己的 props，保持單向資料流。 所有的 React component 都必須像 Pure function 一般保護他的 props。 // not a pure functionfunction withdraw(account, amount) &#123; account.total -= amount;&#125; 5. State 和生命週期 State 類似於 prop，但它是私有且由 component 完全控制的。 component 被定義為 class 有一些額外的特性，其中一個就是 Local State。 將 function 轉為 class 寫法 建立一個繼承 React.Component的 class 加入 render()空方法 return JSX render()內的 props要寫成 this.props 每次更新時，render() 都會被呼叫。 可以使用 local state 和生命週期方法這些額外特性。 需要 constructor()，並在裡頭初始化數據，使用 super(props)，之後組件中就能取得 props。 加入生命週期方法到 Class 當 component 被 destroy 時，釋放所佔用的資源是非常重要的。 componentDidMount()：會在 component 被 render 到 DOM 之後才會執行，也就是掛載完成的意思，可以做些 DOM 長完才能做的事。 componentWillUnMount()：會在 component 即將卸載前觸發這個生命週期方法，在這裡可以執行要釋放佔用資源的方法，避免 Memory leak。 正確的使用 State 要注意的三件事 除非在 constructor 內，不可以直接改 State，要使用 setState() 方法： // 錯誤！組件不會重新渲染this.state.username = 'askiebaby';// 正確！this.setState(&#123; username: 'askiebaby' &#125;); State 更新可能是非同步的 React 會批次處理 setState()的呼叫，合併為單一的更新，提高效能，所以不可以依賴 this.props與 this.state來「直接計算」新的 state。 // 錯誤！this.setState(&#123; counter: this.state.counter + this.props.increment,&#125;); 透過傳入一個 function 可以避免 state 的不準確： // 正確！Arrow functhis.setState((state, props) =&gt; (&#123; counter: this.state.counter + this.props.increment,&#125;));// 正確！Normal functhis.setState(function(state, props) =&gt; ( return &#123; counter: this.state.counter + this.props.increment, &#125;);); Shallow Merge 呼叫 setState() 時，React 會 merge 你提供的 object 到目前的 state。 如果 state 包含數個獨立變數： constructor(props) &#123; super(props); this.state = &#123; posts: [], comments: [] &#125;;&#125;componentDidMount() &#123; // 這樣使用 // 只會覆蓋 comments；而 posts 保持完整，沒被更動 this.setState(&#123; comments &#125;)&#125; 也可獨立的呼叫 setState()： componentDidMount() &#123; fetchPosts().then(response =&gt; &#123; this.setState(&#123; posts: response.posts &#125;); &#125;); fetchComments().then(response =&gt; &#123; this.setState(&#123; comments: response.comments &#125;); &#125;);&#125; 由上而下的「單向資料流」 組件彼此獨立地管理其內部 state，每個組件的 state 只能影響 component tree 以下的組件。 假設，父組件 UserInfo與兩個子組件 Avatar、SocialLink： 子組件 Avatar可以接收從父組件 UserInfo來的 props，但它不知道是誰傳給它的，子組件只負責接收。 &lt;UserInfo&gt; &lt;Avatar fullname=&#123;this.state.fullname&#125; /&gt; &lt;SocialLink platform=&#123;this.state.platform&#125; /&gt;&lt;/UserInfo&gt; 用以下範例，來理解所有 component 都是獨立的： function App() &#123; return ( &lt;div id=\"app\"&gt; &lt;UserInfo /&gt; &lt;UserInfo /&gt; &lt;/div&gt; );&#125;ReactDOM.render( &lt;App /&gt;, document.getElementById('root')) 6. 事件處理器 事件處理器之於 React Element 與 DOM Element 十分相似，有兩點語法上差異：事件名稱寫法、事件的值的型別。 React/DOM 的事件處理，自己再加上 Vue 的比較 React Element 事件的值的型別 寫法範例 避免瀏覽器預設行為 DOM Element 小寫 string onclick={createPost} 可以在 DOM 的 onclick 屬性中使用 return false React Element 小駝峰 function onClick=&quot;createPost()&quot; 在 function 中明確呼叫 preventDefault Vue Element 使用 vue 內建事件處理器 function v-on:click=&quot;createPost&quot; 可以在事件處理器加上 .prevent 後綴，或 function 中呼叫 preventDefault 備註： 只要在 root DOM element 被 render 時加上一個 listener，應用程式已不需要在綁定 listener。 把 event handler 當成該 class 的方法（慣例） 因為 class 的方法在預設上是沒有被綁定（bound）的，沒綁定的話 this 的值將會是 undefined。 Normal function constructor 內綁定。否則每次要當成 props 傳下去時都需要 bind this。 class Toggle extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;isToggleOn: true&#125;; // 為了讓 `this` 能在 callback 中被使用，這裡的綁定是必要的： this.handleClick = this.handleClick.bind(this); &#125; handleClick() &#123; this.setState(state =&gt; (&#123; isToggleOn: !state.isToggleOn &#125;)); &#125; render() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt; &#123;this.state.isToggleOn ? 'ON' : 'OFF'&#125; &lt;/button&gt; ); &#125;&#125;ReactDOM.render( &lt;Toggle /&gt;, document.getElementById('root')); Class Fields：在 CRA（Create-React-App）中是預設可行的。 class LoggingButton extends React.Component &#123; // 這個語法確保 `this` 是在 handleClick 中被綁定： // 警告：這是一個還在*測試中*的語法： handleClick = () =&gt; &#123; console.log('this is:', this); &#125; render() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt; Click me &lt;/button&gt; ); &#125;&#125; callback 中使用 arrow function，缺點：有效能問題，當組件 LoggingButton 每次渲染時都會建立一個不同的 callback，若這 callback 被 props 到下一個組件，會有多餘的 re-render。 class LoggingButton extends React.Component &#123; handleClick() &#123; console.log('this is:', this); &#125; render() &#123; // 這個語法確保 `this` 是在 handleClick 中被綁定： return ( &lt;button onClick=&#123;(e) =&gt; this.handleClick(e)&#125;&gt; Click me &lt;/button&gt; ); &#125;&#125; 原則上以 1. constructor 內綁定 或 2. class field 語法，避免效能問題。 將參數傳給 Event Handler 在傳額外參數 id 給事件處理器時， e 在 Arrow function與 Function.prototype.bind的寫法比較： &lt;button onClick=&#123;(e) =&gt; this.deleteRow(id, e)&#125;&gt;Delete Row&lt;/button&gt;&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/button&gt; Arrow function： e「需要」被明確指定的傳下去，在上述範例中作為第二個參數。 Function.prototype.bind：e「不需要」明確指定，即可傳下去。 Reference Hello World - React Docs","link":"/react-main-concepts-part-1/"},{"title":"簡單 ssh 進 instance，用 ssh_config 來幫你設定 alias","text":"ssh 進機器 常需要 ssh 進機器裡，會使用下列格式的語法： ssh -i ~/.ssh/[your-keyfile] [username]@[private_ip] 如果服務越來越多，我們需要 ssh 進去的機器也變多了，當然我們不可能每次都去找到 IP 再來複製貼上，這樣不僅工作速度慢， content switch 太頻繁會讓人心情不太好。因為超新手的關係，神同事可憐可憐我，貼了凍仁大大的文章讓我學習設定，很容易就能使用 😆，趕緊做筆記下來，一起加速！ ssh_config 如何設定 欄位介紹 Host：ssh 要連的代號名稱。 Hostname：IP 或 Domain Name。 Port：要連進去的 Port 號，ssh 沒改的話，預設 Port 號是 22。 User：使用者名稱。 identityfile：ssh key（絕對位置）。 # ----------------------------------------- ## [STG] Service AHost service-aHostname 10.10.0.1Port 22User askie_linidentityfile ~/.ssh/opsworks# ----------------------------------------- # 如何透過 ~/.ssh/config 連上主機 ssh service-a 哇，真的超簡單，之後又超方便使用的 alias 設定，分享給大家，拯救被浪費的時間。 Reference [完全用 GNU/Linux 工作] 20. 增進 SSH 使用效率 - ssh_config","link":"/lets-set-ssh-config/"},{"title":"RegExp 踩雷：Lookbehind Assertions","text":"RegExp in JavaScript 之前對正規表達式一直不太熟悉，也沒仔細去研究正則規則寫法是什麼種類，所以踩到支援性的雷。大多數正規式會支援正規表達式的原因是，它是一個對於文字操作非常強大的工具，本來要寫數十行複雜邏輯的判斷式，只要一行就能達成。 ES2018 新增的功能 正則表達式在 1999 年在 ECMAScript 標準第三版成為 JavaScript 的一部份，而在 ES2018 標準第九版時，新增了以下的功能，大幅改善對文字處理的能力。這邊文章要說明的是關於 assertions，大部分程式碼範例參考自此篇文章。 Lookbehind assertions Named capture groups a(dot) Flag Unidocde property escapes 這些新功能的支援度目前還不高，尤其是 lookbehind 支援 Assertions 想要 match 文字是否符合規則，需要仰賴文字前後的順序，從而丟棄不合規則的 pattern。尤其是當我們處理到很長的字串，比對的過程中，幾乎都是不正確的格式。好險正則表達式基本上都有提供 lookbehind assertions 和 lookahead assertions，讓我們的格式判斷能有效率。 Lookhead 在 ES2018 之前，JavaScript 有提供lookahead assertion，分為 positive 和 negative。 Positive lookahead 用 (?=...) const re = /Project(?= 10)/;console.log(re.exec('Project')); // nullconsole.log(re.exec('Project5')); // nullconsole.log(re.exec('Project 5')); // nullconsole.log(re.exec('Project 10'));// [\"Project\", index: 0, input: \"Project 10\", groups: undefined] Negative lookahead 用 (?!...) const re2 = /Lucky(?!Star)/;console.log(re2.exec('LuckyStar'));// nullconsole.log(re2.exec('LuckyGuy'));// [\"Lucky\", index: 0, input: \"LuckyGuy\", groups: undefined]console.log(re2.exec('LuckyOne'));// [\"Lucky\", index: 0, input: \"LuckyOne\", groups: undefined]console.log(re2.exec('Lucky'));// [\"Lucky\", index: 0, input: \"Lucky\", groups: undefined] Lookbehind ES2018 ，JavaScript 新增了lookbehind assertions作為 lookahead assertions，一樣分為 positive 和 negative。 Positive lookbehind 用 (?&lt;=...) const re = /(?&lt;=€)\\d+(\\.\\d*)?/;console.log(re.exec('199'));// nullconsole.log(re.exec('$199'));// nullconsole.log(re.exec('€199'));// [\"199\", undefined, index: 1, input: \"€199\", groups: undefined] Negative lookbehind 用 (?&lt;!...) const re = /(?&lt;!\\d&#123;3&#125;) meters/;console.log(re.exec('10 meters'));// [\" meters\", index: 2, input: \"10 meters\", groups: undefined]console.log(re.exec('100 meters'));// null 搭配一同使用 positive lookbehind (?&lt;=...) 和 negative lookbehind (?&lt;!...) const re = /(?&lt;=\\d&#123;2&#125;)(?&lt;!35) meters/;console.log(re.exec('35 meters'));// → nullconsole.log(re.exec('meters'));// → nullconsole.log(re.exec('4 meters'));// → nullconsole.log(re.exec('14 meters'));// → [\"meters\", index: 2, input: \"14 meters\", groups: undefined] 數字要兩位數。 並且，數字不是 35。 符合以上兩個規則， exec() 就會回傳找到的結果陣列。 Reference New JavaScript Features That Will Change How You Write Regex - by Faraz Kelhini Lookbehind in JS regular expressions - Can I Use https://zhuanlan.zhihu.com/p/56981997","link":"/regexp-lookbehind-assertions/"},{"title":"忍者 2：Web 應用程式生命週期","text":"本文內容涵蓋 Web 應用程式生命週期 處理 HTML 以產生網頁 JS 程式碼的執行順序 與事件互動 事件迴圈 Web 應用程式生命週期 Web 應用程式真正的生命起始於第四步驟：收到伺服器回傳的頁面時。 使用者：輸入網址或是點擊超連結 瀏覽器：產生請求並送往伺服器 伺服器：收到請求，執行動作或是取得資源，將回應送回客戶端 瀏覽器：收到回應頁面，解析 HTML、CSS、JavaScript 並渲染頁面 [頁面建立階段] 瀏覽器與使用者：[事件處理] 瀏覽器監看事件佇列 使用者與頁面元素互動 瀏覽器一次處理一個事件 … 持續這個循環 使用者關閉 Web 應用程式 Ｗ eb 應用程式也是一種圖形使用者介面，所以和其他 GUI 應用程式一樣，都是先建立頁面，再進行事件處理直至被使用者關閉，就結束了生命週期。 頁面建立階段 設置使用者頁面。 事件處理階段 進入一個等待事件發生的迴圈，並啟用事件處理器。 生命週期結束 使用者關閉 Web 應用程式。 頁面建立階段 _ (4) 網頁在可以被操作或單純顯示之前，瀏覽器須先根據伺服器接收到的回應內容（HTML、CSS、JavaScript），此階段的目標是「設置 UI」，分為兩個步驟： 解析 HTML 並建立文件物件模型 DOM 執行 JavaScript 程式 瀏覽器處理 HTML 節點時執行「步驟 1」，每次只處理一個節點； 當遇到特殊類型 HTML 元素，即是包含/引用 JavaScript 的 &lt;script&gt;，就執行「步驟 2」。 HTML 節點關係 父節點、子節點、兄弟節點。 瀏覽器能否永遠正確地根據 HTML 產生網頁 DOM 文件物件模型，其實 DOM 不等於 HTML，雖然 DOM 是由 HTML 建構，但 HTML 其實是 DOM 建構時所遵循的藍圖，若建構時發現錯誤，瀏覽器會容錯、修復它，如此才能夠建構「有效」的 DOM。 &lt;head&gt; 的設計意圖 用於提供一般性的頁面訊息，比如說：網頁標題、字元編碼、外部樣式、外部程式。 不是用來定義「頁面內容」（DOM）的，所以如果把非頁面訊息的元素，放進 &lt;head&gt;，會被瀏覽器靜靜地修復，比如說 &lt;p&gt;，就會被默默移動到 &lt;body&gt; 中。 頁面建立階段時，遇到特殊類型 HTML 元素 &lt;script&gt; &lt;script&gt; 元素用來包含 JavaScript 程式碼。 而在這個情況之下，瀏覽器會暫停建立 DOM 結構，而先執行 JavaScript 程式碼。 瀏覽器的 JavaScript 引擎 &lt;script&gt; 中的程式碼，由瀏覽器的 JavaScript 引擎執行，提供頁面動態行為。 Firefox：Spidermonkey Chrome：V8 Opera：V8 Edge(IE)：Chakra JavaScript 全域物件 瀏覽器中 JavaScript 引擎的全域物件是 window 物件，代表頁面所屬的「瀏覽器視窗」。 window 物件是特殊的全域物件，因為它可以存取： 所有其他的全域物件 全域變數（包含使用者自訂的全域變數） 瀏覽器 API window 物件中，最重要的屬性是 document，代表目前頁面的 DOM 結構，透過 document 物件，JavaScript 可以任意建立及插入、修改、刪除等所在頁面的 DOM 結構，但也有一些無法做到的事，比如選取和刪除尚未建立的元素。因為有時 JavaScript 程式碼還沒被讀取，故有些元素還沒透過 JavaScript 建立並插入到 DOM 中，所以有些開發者傾向將 &lt;script&gt; 放在頁面底部。 事件處理階段 _ (5) 頁面互動性 在頁面建立階段，除了修改 DOM 以外，還能註冊事件監聽器（Event Handler），監聽使用者的操作，當某些操作被觸發時，瀏覽器會針對不同類型的事件做出反應，也就是呼叫被定義好要觸發的函式（Callback）。透過這樣的流程，去增加頁面的互動性。 事件處理概述 瀏覽器執行環境的核心是「單一執行緒」，也就是一次只執行一段程式碼。 瀏覽器透過「事件佇列」追蹤已發生但尚未處理的事件，並且這些事件都會按照發生的順序放在同一個事件佇列中。 流程： +---------+ 檢測 +------------------+ 是 +-----------+| 瀏覽器 | =&gt; | 事件佇列頂部有事件？| =&gt; | 執行一個事件 |+---------+ +------------------+ +-----------+ ↑ 繼續檢測 ↓ 否 +-------------+ 將事件放入事件佇列中這件事情，是瀏覽器的工作機制，並不在頁面建立和事件處理階段之中，所以判斷何時該執行、加入佇列的這個動作不在事件處理的執行緒中。 事件是「非同步」的。 絕大多數程式碼會被這些事件類型觸發： 瀏覽器事件：網頁處於已經載入或未載入的狀態 網路事件：Ajax 事件、Server 端事件 使用者事件：使用者點擊滑鼠 計時器事件 註冊事件處理器（Event-handler Registration） 兩種方式可以註冊 將函式只給特定屬性：一次只能指派一個事件處理器，下次註冊就會清空前次的內容。 window.onload = function () &#123;&#125;;document.body.onclick = function () &#123;&#125;; 使用內建的 addEventlistener：針對同個元素，可以新增多個相同或不同的事件處理器。 window.addEventListener('load', function () &#123;&#125;);document.body.addEventListener('click', function () &#123;&#125;); 簡易 QA 一個 Web 應用程式可以同時處理多少個事件？ 一個。 為什麼瀏覽器必須使用事件佇列來處理多個事件？ 因為需要追蹤已經發生但尚未處理的事件。","link":"/javascript-ninja-2-web-lifecyle/"},{"title":"系統設計入門：效能與可擴展性的差異","text":"本系列文並非自己實務心得記錄，而是讀 System Design Primer 的筆記，有蠻大部分節錄自該文章以及其補充連結。 工程師常拿 Scalability 來討論，最後也常以「但是它不能擴」作為雙方的結論。這表示系統確實經常被限縮。 怎樣的服務算是擁有「可擴展性 Scalability」 比如說，為了提高所提供服務的可靠性，需要納入冗餘（Redundancy）的設計理念，降低系統執行對單一伺服器的依賴程度，卻不會因而犧牲效能。 當資源投入時，服務的效能還能增加，也就是「效能增長程度」與「資源投入」成正比時，那麼這個服務即擁有可擴展性。因為效能增加代表服務可以處理更多資料，也就能服務更多的工作單位，我們就擁有擴展資源的可能性，而不會為了會損失效能而選擇折衷，導致服務失去更多可能性。 對於單一個使用者來說 系統存在「效能」問題時，他會覺得「慢」。 系統存在「可擴展性」問題時，他會覺得較快，但系統「高負載」時，就會覺得「變慢」。 比如某些演算法，使用者平常感覺都很良好，只有在系統進入高負載時會影響甚巨。 最難的地方 無法事後設計 因為可擴展性這件事情，必須要在事前先思考、設計、再開始開發，開發後才開始想到這一層面，往往無法因應。 異質性 Heterogeneity 需要考量不同版本的硬體設備都有其異質性，且更強大的工具通常需要付出更昂貴的成本。 Check List 確保系統沿著期望的方向成長 哪裡需要冗餘 應該如何處理系統中的異質性 Solution Architect 需知道在哪些條件下他們可以使用哪些工具以及其常見缺點 Weekly Notes Multi-tier architecture：3-tier Architecture 是最常使用的架構，尤其是電商網站。 Presentation Layer a.k.a. UI layer（Presentation tier） PC, Tablet, Mobile, etc. Application Layer（Logic tier） Web Server Database Server（Data tier） Performance → Scale-up 新增機器，若依舊無法改善就是 Scalability Problem Scalability → Scale-out Web Server Load Balancer / L4 switch 一定要有 health check 一定要有 Policy 流量分配方式： Round-robin 依序循環、 Least connection、 先經過演算法 hash 過，指向 FQDN，印象中是 ELB 預設方式。 DB Server Data Replication，加一層 HA proxy、ProxySQL、Route server (Asynced) - Multi-source 有 Delay 的考量 Binlog 去備份，會自動比較差異 Read：很棒 Write：容易因為 delay 衝突 Scale-out：要寫 script 自動化去 sync (Synced) - PXC - Data Read 量大可以選用的 solution，不然 node 多容易有效能慢的問題 Read：很棒 Write：等所有 DB server 都完成才算真正完成 ⇒ 寫入 Scale-out：自動化同步，但如果 size 大要找一個東西花很久時間 Data Partitioning and Sharding，加一層 Route Server 水平分割：table 只存某種 type，比如身分證字號 A 開頭的存一個表 垂直分割：table 只存某欄位，比如性別欄位存一個表 MongoDB Sharding：透過 Route server 去問 ConfigDB 取得 sharding key，得知要存在哪個表 Write：透過 ConfigDB 知道要寫到哪 Read：透過 ConfigDB 知道要存到哪 Scale-out：加新 node 很輕鬆，只要設定好 ConfigDB，自動化 re-balance data，做更合適的分散。 Jack 分享電商 XXhome 的經驗： 現在的系統做大後要拆分的最根本原因是因為 User 需求量大增。 所以背後有 Cluster 群在服務這些請求。 再把來源拆一拆就能分流： 圖片有專屬的機器 API 也拆一拆 所以雲端服務： 只要背後做得穩、快。 剩下的就是做好使用者經驗，也就是 Front-end + UI/UX ⇒ 我自己的結論。 Reference System Design Primer A Word on Scalability - Werner Vogels Scalability, Availability &amp; Stability Patterns","link":"/system-design-primer-performance-vs-scalability/"},{"title":"系統設計入門：延遲與吞吐量","text":"本系列文並非自己心得記錄，而是讀 System Design Primer 的筆記，有蠻大部分節錄自該文章以及其補充連結。 話說這兩個詞彙（Latency 和 Throughput）常常會被搞混，有時候可以交換使用，不過自己本來不是讀資訊相關背景，加上本身寫前端，看到這兩個字真的是生字，一點實務上的聯想都想不到，如果你也不懂的話，沒關係，下文會寫筆記來解釋…。 定義 Latency 延遲 執行一個操作要花費的「時間長度」。 Throughput 吞吐量 以一個時間區間作為單位，單位時間內可以執行「幾次」操作，或運算的「次數」。 讀的文章提及，系統設計要以： 可接受的延遲數量下的最大化吞吐量為設計目標。 簡單例子 拍謝，有點文鄒鄒看不懂，以簡單例子來舉例： 有個專門製造汽車的工廠，它製造 1 輛汽車所需要的時間是 8 個小時，而它的生產線在 1 天當中可以製造 120 輛汽車。 Latency 延遲：8 小時。 Throughput 吞吐量：1 天 120 輛汽車，或者是 1 個小時 5 輛汽車。 這樣有比較理解了吧！ Latency 指的是單項事件所需花費的「時間、時間、時間」，！ 而 Throughput 則是在一定的時間內能夠完成的「次數、次數、次數」。 系統設計師可以用來根據效能規範建立所需硬體的參數。 How about web Latency in web Latency 是效能的一環，它讓我們得以量化，有所依規的來訂定優化的標準。那以 Web 來說的話，Latency 指的就是使用者自發出請求後，等待伺服器回應並回傳給使用者的總花費時間，也等同代表網站「被訪問的速度」。對於第一個請求，對於前面的 14Kb 位元，延遲時間會比較長，因為它包括 DNS 查詢、 TCP 三次握手和安全 TLS 協定。 在 Chrome 的開發者工具 Network 中，可以將資源按照以下內容排序。 本區段整理自 Aima 這篇文章。 Start Time：請求開始的時間 Response Time：資源開始下載的時間 End Time：請求結束的時間 Total Duration：請求整個完整過程的時間 Latency 請求等待響應的時間 我們這時來看一下，開發者工具 Network 中有什麼常用的功能。 Network on Chrome DevTools 點擊單項請求的內容可以看到 Headers Preview Response Initiator Timing - 連線時間、請求時間、回應時間、檔案下載時間 Cookies - 請求有帶哪些 cookies 關於延遲的 Web 相關技術 圖片的 Lazy Loading 這個部分我有實作過，原理是將圖片的路徑放在 data-set 中，再設定設計好的「載入中 placeholder」，透過 Intersection Observer API 來監聽元素是否進入畫面，當圖片元素進入畫面時，透過 JS 將 src 替換掉。需考量瀏覽器支援度。 延遲載入 3rd party， &lt;script&gt; 的屬性 defer 和 async。 以下兩者載入過程相同：渲染 DOM 與載入 JS 以非同步方式進行。 defer：執行時間要等到 DOM 解析完成後，才會執行。 async：執行時間是在於 JS 本身載入完成後馬上執行，會中斷 HTML 解析。 Preload 和 Prefetch Preload：預先載入，但不執行，只在需要時才執行，以 as 屬性分辨檔案類型。 &lt;link rel=&quot;preload&quot; src=&quot;style.css&quot; as=&quot;style&quot;&gt; Prefetch：告訴瀏覽器未來可能用到這個資源，有空再去載就好。 &lt;link rel=&quot;prefetch&quot; src=&quot;style.css&quot; type=&quot;style&quot;&gt; Webpack Code spliting Lodash Throttle、Debounce 關於 Latency 的介紹，可以看 MDN 介紹。 Resource System Design Primer Understanding Latency versus Throughput Understanding latency - MDN Preload vs Prefetch - Summer","link":"/system-design-primer-latency-vs-throughput/"},{"title":"My love","text":"2014 年 1 月 25 日 週六 第一次遇見她的日子 她才一個月大 誤打誤撞地推翻原本的計畫 唸書的我能照顧她的餘生嗎？ 抱著無論如何都不讓她再受風吹雨淋的決心 直到了現在都沒有停 貓咪的個性跟人很像 因為，每隻貓咪個性都截然不同 喜歡黏我撒嬌加上強烈的佔有慾 傲嬌的她，總是使出渾身解數的表演吸眼球 她愛我就如同我愛她的深度 陪伴跟傾聽是她會的 她甚至，還會保護我 在我最脆弱的時候","link":"/nami-introduction/"},{"title":"Docker 初探：基本指令與簡單介紹 Dockerfile 和 docker-compose","text":"TL;DR 本文不會有太多語法說明，打算介紹： Docker 的前世今生 Container 名稱由來 如何運行基本的 Docker 指令 簡單介紹 Dockerfile 和 docker-compose 的用途（新手常搞不清楚） 一切內容僅是讀書紀錄，讀的書請參考本文最下方的 Reference，如果有錯誤請大家指正觀念。 讀 Docker 背景之前覺得會不會因為文鄒鄒讀不下去，讀完之後才發現只有這樣才能更了解歷史脈絡，以及這個技術背後的基礎是基於什麼，也是挺有趣的。 Docker 的前世今生 Containers are based on virtualization technology. 虛擬化技術 電腦出現之後，開發者思考的是如何將程式無縫移植到其他機器還能正常執行，由於不同廠商生產的 CPU 其指令集往往差異很大、機器會連接不同硬體、運行不同作業系統等原因，所以環境一致性是最困擾的問題。在這方面，IBM 是做最早提出虛擬化的公司（60 年代），讓程式執行於虛擬環境時，看不見被隱藏的真實環境，取而代之的是被事先設定好的硬體環境，從而彌平環境問題。 硬體虛擬化 當時的解決方案僅限解決 IBM 大型硬體機器，成本過高，於當時也不易推廣。從前的大型網站通常採用大型實體機器，網路發展快速，漸而轉向小型機器發展，隨著雲端計算時代來臨，計算的量變得巨大，升級機器的成本指數成長，好可怕！ 分散式系統 現在大型服務可以透過將應用程式分散到各地不同的小型機器上，再組成叢集一起計算、協作，完成該服務需提供的工作，就可稱作分散式系統。當很多大公司開始採用叢集方式建構服務，比如臉書，程式部署在不同機器上的環境問題又浮上檯面。（叢集定義可查看 wiki、鳥哥更多介紹） 而「虛擬化技術」是電腦資源的管理技術，CPU、Storage、Network，將資源抽象化為統一介面給程式。 軟體虛擬化 虛擬機器（Virtual Machine）就是軟體實作，通常會在應用程式和硬體資源將建立一個 Hypervisor 層，它是統一的呼叫介面，將呼叫轉換為實體主機對應的資源呼叫方式。 容器化技術 虛擬機器，簡稱 VM，在跨平台部署有很好的表現，只是低落效率阻礙它的發展，而後衍伸了容器化技術的概念：將應用程式打包到單獨的容器中、封裝，容器可以隔離每個程式並打斷程式的依賴關係。 好處： 就像堆積木（Component）一樣，結構鬆散，降低程式之間藕合性 擁有統一的介面，很容易重新組裝和抽換服務的功能 提一下 Linux Containers（LXC）它是作業系統層級的虛擬化技術/容器，它運用實體機器資源再模擬虛擬環境，所以移除 Hypervisor 層，不用再轉換指令，大幅提高效率囉！ 主要有兩項核心功能組成： Namespace 命名空間 隔離的用途 很容易將不同程式隔離在不同環境，也就是說不同命名空間的程式是互不可見 CGroups （Control Group）控制群組 資源管控 如同大腦般的控制該容器可用的電腦資源：CPU、Memory、IO Docker 2013 年，dotCloud 公司將內部開發的 Docker 開源，基於上面提到的 LXC 技術基礎，將系統設計容器轉為微服務（Micro-service）的容器！因為很火熱，dotCloud 後來索性改名叫做 Docker Inc 現在成熟的 Docker 已經不是以 LXC 為架構，而是自己開發的 Libcontainer 作為底層的技術。 我們不用再管虛擬化怎麼實現的，只要管容器該怎麼操作！ （翻譯蒟蒻：只要管積木該怎麼拼 ⇒ 只要管程式元件該怎麼組成）。 Docker 啟動與執行 啟動：啟動 Docker 時，其實啟動的是背後的 Server - Docker Daemon 執行：控制 Docker CLI，透過 Docker REST API 發送指令給 Docker Daemon Docker 四大核心模組 Image 映像 ⇒ 容器要打包的程式 Container 容器 ⇒ 隔離好的環境 Data Volumes Network Container 容器一詞的由來 早期的運輸皆是靠海運，因為貨物規格、形狀、材質都不一樣，工人為了最大化運用船的空間，需要花費大量時間裝卸。碼頭數量有限，如果每一艘船都很慢，效率很不佳，直到貨櫃的發明，貨櫃被設計成規格大小皆一致，大大提升運輸效率，促進全球化。 Container 的中文翻譯就是貨櫃的意思。 貨櫃：把「貨物」隔離到不同「箱子」中，消除「不同貨物規格」的影響。 容器：把「程式」隔離到不同「容器」中，消除「不同執行環境」的影響。 Docker Image 顯示：askie/helloworld:lastest 格式：Namespace/Repository:Tag 由此格式會用 Sha256 方式加密成為 Image ID （64 位元 16 進位字串） Namespace：用來辨別組織或個人，可以寫自己名字 Repository：檔案名稱，寫應用程式名稱 Tag：參考 Git 的 Tag，也是用來記錄程式的版本 Docker 基本使用流程 超級類似 GIT 的概念吧！ DockerHub（Public） 類似 GitHub，是可以上傳跟下載的 Docker 公開庫。 Docker Registry（Private） 有些企業會考量隱私性及安全性，在內部網路架設一台 Docker Registry Server（Private）。 Local 端安裝好 Docker 之後… 安裝流程請參考官網，這裡不贅述。 1. 拉一個 Image 回來 檢視現有 Image 有哪些： docker image ls 假設拉一個普羅米修斯回來： docker pull prom/promtheus 還記得 image 格式 Namespace/Repository:Tag？不加 tag 時，預設會拉最新版本回來！ 2. Container 跑起來 Run 起一個 Container：用 prom/promtheus 這個 image 背景執行一個容器環境，取名叫做 prom-server。 docker run -d -p 9090:9090 --name prom-server prom/promtheus 參數說明： -d 背景執行 -p port 號設定，本機 9090 port 來對應虛擬環境的 9090 port —-name 容器名稱 3. 進入 Container 執行環境 docker exec -it prom-server /bin/sh......做你要做的事情 進入執行環境中的 /bin/sh 資料夾下，類似於 SSH 進入機器的概念 4. 版控更新過的 Container 環境 docker commit -m \"test\" &lt;your_image_id&gt; askie/prometheus:v2 -m 輸入版本控制的訊息狀態 your_image_id 透過 docker image ls 取得要紀錄的 ID 5. 將新 Image 推到 Docker Registry docker logindocker push askie/prometheus:v2 要 login 需註冊並且有權限 Dockerfile Dockerfile 是一個設定檔，專門管理單一 Container，讓我們可以透過指令的設定，快速地更新 Container 的環境。 Dockerfile 檔案內容，注意，首字大寫 透過 Docker CLI 來快速更新容器環境 docker build -t vrops_prometheus docker-compose 現在很多服務背後都是採用分散式系統的架構，所以一個微服務用一個容器裝起來，眾多的微服務，就需要使用可以管理多個 Container 的工具 docker-compose。（題外話：有了 K8S，基本上工作上都是採用 K8S 來管理多個容器，功能強大！） 它的基本指令很簡單，其原理是撰寫 docker-compose.yml 來設定你的 services 該指向哪些 image、Port 對應、該走哪些任務。 docker-compose startdocker-compose stopdocker-compose pausedocker-compose unpausedocker-compose psdocker-compose updocker-compose down CheatSheet 有了以上這些基礎觀念之後，接下來只要熟悉語法即可。 Docker CLI CheatSheet Dockerfile CheatSheet docker-compose CheatSheet 好了，初探就介紹到這裡了，歡迎指正，也希望對新手有點幫助，觀念通了工具用起來才有感覺。 Reference Docker 專業養成 活用基礎與實踐技能 — 熊昌隆 我同事","link":"/docker-dockerfile-dockercompose-intro/"}],"tags":[{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"array","slug":"array","link":"/tags/array/"},{"name":"object","slug":"object","link":"/tags/object/"},{"name":"json","slug":"json","link":"/tags/json/"},{"name":"callback","slug":"callback","link":"/tags/callback/"},{"name":"function","slug":"function","link":"/tags/function/"},{"name":"asyncronous","slug":"asyncronous","link":"/tags/asyncronous/"},{"name":"closure","slug":"closure","link":"/tags/closure/"},{"name":"map","slug":"map","link":"/tags/map/"},{"name":"loop","slug":"loop","link":"/tags/loop/"},{"name":"switch","slug":"switch","link":"/tags/switch/"},{"name":"mobile","slug":"mobile","link":"/tags/mobile/"},{"name":"test","slug":"test","link":"/tags/test/"},{"name":"terminal","slug":"terminal","link":"/tags/terminal/"},{"name":"command line","slug":"command-line","link":"/tags/command-line/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"diff","slug":"diff","link":"/tags/diff/"},{"name":"ngrok","slug":"ngrok","link":"/tags/ngrok/"},{"name":"https","slug":"https","link":"/tags/https/"},{"name":"web server","slug":"web-server","link":"/tags/web-server/"},{"name":"api","slug":"api","link":"/tags/api/"},{"name":"testing","slug":"testing","link":"/tags/testing/"},{"name":"chatbot","slug":"chatbot","link":"/tags/chatbot/"},{"name":"jquery","slug":"jquery","link":"/tags/jquery/"},{"name":"ajax","slug":"ajax","link":"/tags/ajax/"},{"name":"multipart/formdata","slug":"multipart-formdata","link":"/tags/multipart-formdata/"},{"name":"boundary","slug":"boundary","link":"/tags/boundary/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"command","slug":"command","link":"/tags/command/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"huli","slug":"huli","link":"/tags/huli/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"react track","slug":"react-track","link":"/tags/react-track/"},{"name":"react入門","slug":"react入門","link":"/tags/react入門/"},{"name":"arrow function","slug":"arrow-function","link":"/tags/arrow-function/"},{"name":"this","slug":"this","link":"/tags/this/"},{"name":"deep copy","slug":"deep-copy","link":"/tags/deep-copy/"},{"name":"swallow copy","slug":"swallow-copy","link":"/tags/swallow-copy/"},{"name":"深拷貝","slug":"深拷貝","link":"/tags/深拷貝/"},{"name":"淺拷貝","slug":"淺拷貝","link":"/tags/淺拷貝/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"css specificity","slug":"css-specificity","link":"/tags/css-specificity/"},{"name":"權重","slug":"權重","link":"/tags/權重/"},{"name":"特定度","slug":"特定度","link":"/tags/特定度/"},{"name":"優先權","slug":"優先權","link":"/tags/優先權/"},{"name":"javascript variable","slug":"javascript-variable","link":"/tags/javascript-variable/"},{"name":"var","slug":"var","link":"/tags/var/"},{"name":"let","slug":"let","link":"/tags/let/"},{"name":"const","slug":"const","link":"/tags/const/"},{"name":"scope","slug":"scope","link":"/tags/scope/"},{"name":"git log","slug":"git-log","link":"/tags/git-log/"},{"name":"git commit","slug":"git-commit","link":"/tags/git-commit/"},{"name":"git alias","slug":"git-alias","link":"/tags/git-alias/"},{"name":"條件判斷","slug":"條件判斷","link":"/tags/條件判斷/"},{"name":"if else","slug":"if-else","link":"/tags/if-else/"},{"name":"javascript conditions","slug":"javascript-conditions","link":"/tags/javascript-conditions/"},{"name":"js conditions","slug":"js-conditions","link":"/tags/js-conditions/"},{"name":"javascript statement","slug":"javascript-statement","link":"/tags/javascript-statement/"},{"name":"js statement","slug":"js-statement","link":"/tags/js-statement/"},{"name":"活動","slug":"活動","link":"/tags/活動/"},{"name":"辦活動","slug":"辦活動","link":"/tags/辦活動/"},{"name":"餐點","slug":"餐點","link":"/tags/餐點/"},{"name":"食物中毒","slug":"食物中毒","link":"/tags/食物中毒/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"bundle","slug":"bundle","link":"/tags/bundle/"},{"name":"modules","slug":"modules","link":"/tags/modules/"},{"name":"模組化","slug":"模組化","link":"/tags/模組化/"},{"name":"打包工具","slug":"打包工具","link":"/tags/打包工具/"},{"name":"webpack loader","slug":"webpack-loader","link":"/tags/webpack-loader/"},{"name":"webpack plugin","slug":"webpack-plugin","link":"/tags/webpack-plugin/"},{"name":"webpack css-loader","slug":"webpack-css-loader","link":"/tags/webpack-css-loader/"},{"name":"webpack style-loader","slug":"webpack-style-loader","link":"/tags/webpack-style-loader/"},{"name":"bulma","slug":"bulma","link":"/tags/bulma/"},{"name":"css framework","slug":"css-framework","link":"/tags/css-framework/"},{"name":"rwd","slug":"rwd","link":"/tags/rwd/"},{"name":"css-in-js","slug":"css-in-js","link":"/tags/css-in-js/"},{"name":"css modules","slug":"css-modules","link":"/tags/css-modules/"},{"name":"css scoped","slug":"css-scoped","link":"/tags/css-scoped/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"前端精神時光屋","slug":"前端精神時光屋","link":"/tags/前端精神時光屋/"},{"name":"無障礙規範","slug":"無障礙規範","link":"/tags/無障礙規範/"},{"name":"通用設計","slug":"通用設計","link":"/tags/通用設計/"},{"name":"無障礙設計","slug":"無障礙設計","link":"/tags/無障礙設計/"},{"name":"aria-label","slug":"aria-label","link":"/tags/aria-label/"},{"name":"Accessibility","slug":"Accessibility","link":"/tags/Accessibility/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"Accessibile Web","slug":"Accessibile-Web","link":"/tags/Accessibile-Web/"},{"name":"vscode","slug":"vscode","link":"/tags/vscode/"},{"name":"custom user code snippets","slug":"custom-user-code-snippets","link":"/tags/custom-user-code-snippets/"},{"name":"code snippets","slug":"code-snippets","link":"/tags/code-snippets/"},{"name":"user snippets","slug":"user-snippets","link":"/tags/user-snippets/"},{"name":"step by step","slug":"step-by-step","link":"/tags/step-by-step/"},{"name":"snippet generator","slug":"snippet-generator","link":"/tags/snippet-generator/"},{"name":"sitemap","slug":"sitemap","link":"/tags/sitemap/"},{"name":"google search console","slug":"google-search-console","link":"/tags/google-search-console/"},{"name":"seo","slug":"seo","link":"/tags/seo/"},{"name":"a11y","slug":"a11y","link":"/tags/a11y/"},{"name":"好想工作室","slug":"好想工作室","link":"/tags/好想工作室/"},{"name":"無障礙網站","slug":"無障礙網站","link":"/tags/無障礙網站/"},{"name":"無障礙","slug":"無障礙","link":"/tags/無障礙/"},{"name":"w3HexSchool","slug":"w3HexSchool","link":"/tags/w3HexSchool/"},{"name":"development","slug":"development","link":"/tags/development/"},{"name":"tools","slug":"tools","link":"/tags/tools/"},{"name":"開發環境","slug":"開發環境","link":"/tags/開發環境/"},{"name":"MacOS","slug":"MacOS","link":"/tags/MacOS/"},{"name":"ssh","slug":"ssh","link":"/tags/ssh/"},{"name":"regexp","slug":"regexp","link":"/tags/regexp/"},{"name":"lookbehind assertions","slug":"lookbehind-assertions","link":"/tags/lookbehind-assertions/"},{"name":"正規表達式","slug":"正規表達式","link":"/tags/正規表達式/"},{"name":"ninja","slug":"ninja","link":"/tags/ninja/"},{"name":"javascript ninja 2","slug":"javascript-ninja-2","link":"/tags/javascript-ninja-2/"},{"name":"讀書筆記","slug":"讀書筆記","link":"/tags/讀書筆記/"},{"name":"system design","slug":"system-design","link":"/tags/system-design/"},{"name":"nami","slug":"nami","link":"/tags/nami/"},{"name":"cat","slug":"cat","link":"/tags/cat/"},{"name":"貓咪","slug":"貓咪","link":"/tags/貓咪/"},{"name":"娜美","slug":"娜美","link":"/tags/娜美/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"dockerfile","slug":"dockerfile","link":"/tags/dockerfile/"},{"name":"docker-compose","slug":"docker-compose","link":"/tags/docker-compose/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"Server","slug":"Server","link":"/categories/Server/"},{"name":"GIT","slug":"GIT","link":"/categories/GIT/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"React","slug":"React","link":"/categories/React/"},{"name":"API","slug":"Server/API","link":"/categories/Server/API/"},{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"活動","slug":"活動","link":"/categories/活動/"},{"name":"Webpack","slug":"Webpack","link":"/categories/Webpack/"},{"name":"UserExperience","slug":"UserExperience","link":"/categories/UserExperience/"},{"name":"Efficiency","slug":"Efficiency","link":"/categories/Efficiency/"},{"name":"A11Y","slug":"A11Y","link":"/categories/A11Y/"},{"name":"Tools","slug":"Tools","link":"/categories/Tools/"},{"name":"Study Notes","slug":"JavaScript/Study-Notes","link":"/categories/JavaScript/Study-Notes/"},{"name":"System Design","slug":"System-Design","link":"/categories/System-Design/"},{"name":"Nami","slug":"Nami","link":"/categories/Nami/"},{"name":"Docker","slug":"Docker","link":"/categories/Docker/"}]}